; create_dns_query_buffer
; Parameters
;        a4=pointer to (QL format) string representing address to resolve
; Returns:
;        d0 = status code, 0 == ok, -1 == error
;        d5 = total length of formatted
;        a0 = pointer to buffer containing the formatted DNS query
;

dns_qhl  equ      12                ; DNS header length is 12 bytes
dns_qqt  equ      4                 ; Four bytes at end of a query question
TYPE_A   equ      1
CLASS_IN equ      1
; Calculate the number of bytes required for the dns query message including trailing and leading byte of message string null and dns header
; and query record trailer
create_dns_query_buffer
         move.w   (a4),d1
         add.w    #dns_qhl+dns_qqt+2,d1               ; Two extra bytes for 'label' -> '0x05label0x00'
         move.w   d1,d5                               ; Save total length in d5 where it will be returned to caller
         move.b   #MT_ALCHP,d0
         moveq    #-1,d2                              ; Current job
         trap     #1
         tst.l    d0
         bne      alloc_fail                          ; Got less than the requested # of bytes
         cmp.l    d5,d1
         bcs      alloc_fail_release                  ; Did we get the number of bytes requested
; a0 now points to allocated buffer area and a1 still points to start of address to resolve
         movea.l  a0,a2                               ; a2 used as base address for copying into
insert_trailer
         move.w   (a4)+,d1                            ; Length of string that was passed in
         lea      dns_qhl(a2),a3
         bsr      address_to_query_format
         bne      alloc_fail_release                  ; If conversion failed then release memory and exit with error
; N.B. query name is not necessarily word-aligned so we can't use word sized operations in the following
         move.b   #0,(a3)+
         move.b   #TYPE_A,(a3)+                       ; query for A records
         move.b   #0,(a3)+
         move.b   #CLASS_IN,(a3)+                     ; Class Internet
fill_header
         move.w   #0,(a2)                             ; Id for query. TODO: fill in ID of current job
         move.w   #1,4(a2)                            ; Number of questions
         move.w   #0,6(a2)                            ; Number of answers
         move.w   #0,8(a2)                            ; Number of authority resource records
         move.w   #0,10(a2)                           ; Number of additional resource records
set_header_flags
         move.w   #0,2(a2)                            ; Reset all flags
         bset     #0,2(a2)                            ; Recursion desired
         moveq    #0,d0
         rts
; Convert an address to the DNS question format
; E.g. news.lekane.com is converted to 0x04news0x06lekane0x03com0x00 (0xNN a single byte with hex value NN)
; Parameters
; a3 should point to beginning of buffer where the converted address should be written to
; N.B: at least one byte of space should be available for the case when the address in question is '.'
; a4 points to start of string to be converted
; d1.w contains length of string to be converted
; Returns:
; d0=0 means conversion succeeded
; d0=1 means the string to be converted was empty, target buffer is not written to
; d0=2 means string to be converted was an illegal dns name, e.g. ".."
address_to_query_format
         tst.w    d1
         beq      convert_empty_string
         cmpi.w   #255,d1                             ; Maximum total length of name is 255 bytes says the RFC
         bhi      convert_name_too_long
         move.w   d1,d4
         subq.w   #1,d1                               ; Set up for dbra loop which runs until d1==-1
         movea.l  a4,a1
         moveq    #0,d3                               ; d3 == length of current label (== part of dns address)
cloop
         move.b   (a4)+,d2
         cmpi.b   #'.',d2
         beq      cloop_end_label
         addq.w   #1,d3
         dbra     d1,cloop
         bra      clabel_write_label
cloop_end_label
         cmpi.w   #0,d1                               ; Is this the last character of the address?
         bne      cloop_test_illegal                  ; If not, test for illegal label preceding this label terminator
         cmpi.w   #1,d4                               ; It is last char: was the original length of address == 1
         beq      convert_add_null_terminator         ; Then we have address '.' which is a valid query, add null and terminate
cloop_test_illegal
         tst.w    d3                                  ; Check if current label is empty
         beq      convert_illegal_label               ; '..' in an address is illegal
         cmpi.w   #63,d3
         bhi      convert_illegal_label               ; Max length of a single label is 63 bytes (RFC 1035)
clabel_write_label
         move.b   d3,(a3)+                            ; Write label length to target
         subq.w   #1,d3
clabel_loop
         move.b   (a1)+,(a3)+
         dbra     d3,clabel_loop
         moveq    #0,d3                               ; Reset label length to zero, i.e. begin new label
         tst.w    d1
         blt      convert_add_null_terminator         ; This was the last label in the address without an ending '.'
         adda.l   #1,a1                               ; Skip over the '.' in source string
         dbra     d1,cloop
convert_add_null_terminator
         move.b   #0,(a3)+
         moveq    #0,d0
         rts
convert_empty_string
         moveq    #1,d0
         rts
convert_illegal_label
         moveq    #2,d0
         rts
convert_name_too_long
         moveq    #3,d0
         rts
; Allocation returned less bytes than we need - release the allocated block
alloc_fail_release
         moveq    #MT_RECHP,d0                        ; and return an error to the caller
         trap     #1
alloc_fail
         moveq    #-1,d0
         rts

#include "nslookup_h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
int main() /*do you know what is int main() ? */
{
	unsigned char hostname[100];
	initW5300();
	printf("\nEnter Hostname to Lookup : ");
	gets((char*)hostname);
	ngethostbyname(hostname);
	return 0;
}

unsigned short readWord(unsigned char *address) {
	unsigned short value;
	value = (address[0]<<8) + address[1];
}

void ngethostbyname(unsigned char *host)
{
	unsigned char response[100];
	uint8 *buf,*qname,*reader;
	int i , j , stop;
	SOCKET s = 0;  /* Number of socket to use: 0-7 */

	struct RES_RECORD answers[20],auth[20],addit[20]; /*the replies from the DNS server */

	struct DNS_HEADER *dns = NULL;
	struct QUESTION *qinfo = NULL;

	/*Set the DNS structure to standard queries */
	buf = (uint8 *)malloc(2048);
	dns = (struct DNS_HEADER *)buf;

	dns->qr = 0; /*This is a query */
	dns->opcode = 0; /*This is a standard query */
	dns->aa = 0; /*Not Authoritative */
	dns->tc = 0; /*This message is not truncated */
	dns->rd = 1; /*Recursion Desired */
	dns->ra = 0; /*Recursion not available! hey we dont have it (lol) */
	dns->z = 0;
	dns->ad = 0;
	dns->cd = 0;
	dns->rcode = 0;
	
	dns->id = (unsigned short)42; /*Query id of 42*/
	dns->q_count = 1; /*we have only 1 question */
	dns->ans_count = 0;
	dns->auth_count = 0;
	dns->add_count = 0;
	/*point to the query portion */
	qname =(unsigned char*)&(buf[sizeof(struct DNS_HEADER)]);

	ChangetoDnsNameFormat(qname,host);
	qinfo =(struct QUESTION*)&(buf[sizeof(struct DNS_HEADER) + (strlen((const char*)qname) + 1)]); /*fill it */
	printf("qinfo: %u\n", qinfo);
	qinfo->qtype_h = 0; /* we are requesting the ipv4 address */
	qinfo->qtype_l = 1; /* we are requesting the ipv4 address */
	qinfo->qclass_h = 0; /* internet */
	qinfo->qclass_l = 1; /* internet */

	printf("Buf base: %d,dns=%d qname=%d, contents:\n",buf,dns,qname);
	dump((uint8 *)dns,sizeof(struct DNS_HEADER) + (strlen((const char*)qname) + 1) + sizeof(QUERY));
	printf("Press enter to continue ");
	gets((char*)response);
	printf("\nOpening socket...");
	socket(s,Sn_MR_UDP,4224,0);
	printf("\nSending Packet...");
	send_udp(s, buf, (uint32)sizeof(struct DNS_HEADER) + (strlen((const char*)qname)+1) + sizeof(struct QUESTION));
	printf("Sent");

	printf("\nReceiving answer...");
	read_udp(s, buf, 2048);
	printf("Received.\n");
	close(s);
	dns=(struct DNS_HEADER*)buf;

	/*move ahead of the dns header and the query field */
	reader=&(buf[sizeof(struct DNS_HEADER) + (strlen((const char*)qname)+1) + sizeof(struct QUESTION)]);

	printf("\nThe response contains : ");
	printf("\n %d Questions.",dns->q_count);
	printf("\n %d Answers.",dns->ans_count);
	printf("\n %d Authoritative Servers.",dns->auth_count);
	printf("\n %d Additional records.\n\n",dns->add_count);

	/*reading answers */
	stop=0;

	for(i=0;i<dns->ans_count;i++)
	{
		unsigned short type;
		
		answers[i].name=ReadName(reader,buf,&stop);
		printf("Answer #%d name is %s.", i,answers[i].name);
		reader = reader + stop;

		answers[i].resource = (struct R_DATA*)(reader);
		printf("Resource dump:\n");
		dump((uint8 *)answers[i].resource, (uint32)sizeof(struct R_DATA));
		reader = reader + sizeof(struct R_DATA);
		type = readWord((unsigned char *)&(answers[i].resource->type));
		printf("Type = %u\n",type);
		if( type == 1) /*if its an ipv4 address */
		{
			unsigned short data_len;
			data_len = readWord((unsigned char *)&(answers[i].resource->data_len));
			printf("Found an IP v4 address, allocating %d bytes for rdata.\n", data_len);
			answers[i].rdata = (unsigned char*)malloc(data_len);

			for(j=0 ; j<data_len ; j++)
			answers[i].rdata[j]=reader[j];

			answers[i].rdata[data_len] = '\0';

			reader = reader + data_len;

		}
		else
		{
			printf("Found something else.");
			answers[i].rdata = ReadName(reader,buf,&stop);
			reader = reader + stop;
		}
	}

	/*read authorities */
/*
	for(i=0;i<dns->auth_count;i++)
	{
		auth[i].name=ReadName(reader,buf,&stop);
		reader+=stop;

		auth[i].resource=(struct R_DATA*)(reader);
		reader+=sizeof(struct R_DATA);

		auth[i].rdata=ReadName(reader,buf,&stop);
		reader+=stop;
	}
*/
	/*read additional */
/*
	for(i=0;i<dns->add_count;i++)
	{
		addit[i].name=ReadName(reader,buf,&stop);
		reader+=stop;

		addit[i].resource=(struct R_DATA*)(reader);
		reader+=sizeof(struct R_DATA);

		if(addit[i].resource->type==1)
		{
		addit[i].rdata = (unsigned char*)malloc(addit[i].resource->data_len);
		for(j=0;j<addit[i].resource->data_len;j++)
		addit[i].rdata[j]=reader[j];

		addit[i].rdata[addit[i].resource->data_len]='\0';
		reader+=addit[i].resource->data_len;

	}
	else
	{
		addit[i].rdata=ReadName(reader,buf,&stop);
		reader+=stop;
	}
	}
*/
	/*print answers */
	for(i=0;i<dns->ans_count;i++)
	{
		unsigned short type;
		type = readWord((unsigned char *)&(answers[i].resource->type));
		/*printf("\nAnswer : %d",i+1); */
		printf("Name : %s ",answers[i].name);

		if(type==1) /*IPv4 address */
		{
			unsigned char *p;
			p=(unsigned char*)answers[i].rdata;
			printf("has IPv4 address : %u.%u.%u.%u",p[0],p[1],p[2],p[3]);
		}
		if(type==5) /*Canonical name for an alias */
		{
			printf("has alias name : %s",answers[i].rdata);
		}

		printf("\n");
	}

	/*print authorities */
/* 	for(i=0;i<dns->auth_count;i++)
	{
		printf("\nAuthorities : %d",i+1);
		printf("Name : %s ",auth[i].name);
		if(auth[i].resource->type==2)
		{
			printf("has authoritative nameserver : %s",auth[i].rdata);
		}
		printf("\n");
	}
 */
	/*print additional resource records */
/*	for(i=0;i<dns->add_count;i++)
	{
		printf("\nAdditional : %d",i+1);
		printf("Name : %s ",addit[i].name);
		if(addit[i].resource->type==1)
		{
			char *p;
			p=(char*)addit[i].rdata;
			printf("has IPv4 address : %u.%u.%u.%u",p[0],p[1],p[2],p[3]);
		}
		printf("\n");
	}
*/
	free(buf);
	return;
}

unsigned char* ReadName(unsigned char* reader,unsigned char* buffer,int* count)
{
	unsigned char *name;
	unsigned int p=0,jumped=0,offset;
	int i , j;

	*count = 1;
	name = (unsigned char*)malloc(256);

	name[0]='\0';

	/*read the names in 3www6google3com format */
	while(*reader!=0)
	{
		if(*reader>=192)
		{
			offset = (*reader)*256 + *(reader+1) - 49152; /*49152 = 11000000 00000000 ;) */
			reader = buffer + offset - 1;
			jumped = 1; /*we have jumped to another location so counting wont go up! */
		}
		else
		{
			name[p++]=*reader;
		}

		reader=reader+1;

		if(jumped==0) *count = *count + 1; /*if we havent jumped to another location then we can count up */
	}

	name[p]='\0'; /*string complete */
	if(jumped==1)
	{
		*count = *count + 1; /*number of steps we actually moved forward in the packet */
	}

	/*now convert 3www6google3com0 to www.google.com */
	for(i=0;i<(int)strlen((const char*)name);i++)
	{
		p=name[i];
		for(j=0;j<(int)p;j++)
		{
			name[i]=name[i+1];
			i=i+1;
		}
		name[i]='.';
	}

	name[i-1]='\0'; /*remove the last dot */

	return name;
}

/*this will convert www.google.com to 3www6google3com ;got it :) */
void ChangetoDnsNameFormat(unsigned char* dns,unsigned char* host)
{
	int lock=0 , i;
	unsigned char *orig_dns;

	orig_dns = dns;
	strcat((char*)host,".");

	for(i=0 ; i<(int)strlen((char*)host) ; i++)
	{
		if(host[i]=='.')
		{
			*dns++=i-lock;
			for(;lock<i;lock++)
			{
				*dns++=host[lock];
			}
			lock++; /*or lock=i+1; */
		}
	}
	*dns++='\0';
	printf("Convert from %s to %s\n",host,orig_dns);
}

void initW5300() {
   uint8 tx_mem_conf[8] = {8,8,8,8,8,8,8,8};          /* for setting TMSR regsiter */
   uint8 rx_mem_conf[8] = {8,8,8,8,8,8,8,8};          /* for setting RMSR regsiter */
   
   uint8 ip[4] = {192,168,0,77};                   /* for setting SIP register */
   uint8 gw[4] = {192,168,0,1};                     /* for setting GAR register */
   uint8 sn[4] = {255,255,255,0};                     /* for setting SUBR register */
   uint8 mac[6] = {0x00,0x08,0xDC,0x00,111,200};      /* for setting SHAR register */
   
   /* initiate W5300 */
   iinchip_init();

   /* allocate internal TX/RX Memory of W5300 */
   if(!sysinit(tx_mem_conf,rx_mem_conf))           
   {
      printf("MEMORY CONFIG ERR.\r\n");
      exit(1);
   }

   /*setMR(getMR()|MR_FS);                            // If Little-endian, set MR_FS. */
   
   setSHAR(mac);                                      /* set source hardware address */
   /* configure network information */
	setGAR(gw);                                     /* set gateway IP address */
	setSUBR(sn);                                    /* set subnet mask address */
	setSIPR(ip);                                    /* set source IP address */
   
   /* verify network information */
   getSHAR(mac);                                      /* get source hardware address */
   getGAR(gw);                                        /* get gateway IP address */
   getSUBR(sn);                                       /* get subnet mask address */
   getSIPR(ip);                                       /* get source IP address */
   
   printf("SHAR : %02x:%02x:%02x:%02x:%02x:%02x\r\n",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
   printf("GWR  : %d.%d.%d.%d\r\n",gw[0],gw[1],gw[2],gw[3]);
   printf("SUBR : %d.%d.%d.%d\r\n",sn[0],sn[1],sn[2],sn[3]);
   printf("SIPR : %d.%d.%d.%d\r\n",ip[0],ip[1],ip[2],ip[3]);
}

void send_udp(SOCKET s, uint8* buf, uint32 len)
{
	/*Use the open dns servers - 208.67.222.222 and 208.67.220.220 */
	/*dest.sin_addr.s_addr=inet_addr("208.67.222.222");*/

   uint8 destip[4] = {192,168,0,1};
   uint16 destport = 53;
   
   printf("Sending to %d.%d.%d.%d(%d) %d bytes\r\n",destip[0],destip[1],destip[2],destip[3],destport,len);
   printf("Buffer base %d with contents:\r\n",buf);
   /* dump(buf,len); */
   switch(getSn_SSR(s))
   {
      case SOCK_UDP:
            if(len !=sendto(s,buf,len,destip,destport))
            {
               printf("%d : Sendto Fail.len=%d,",s,len);
               printf("%d.%d.%d.%d(%d)\r\n",destip[0],destip[1],destip[2],destip[3],destport);
            }
         break;
      default:
		printf("UDP send failed. Socket not in SOCK_UDP state. Closing socket.\n");
		close(s);
        break;
   }
}

void read_udp(SOCKET s, uint8* buf, uint32 len)
{
   uint8 destip[4];
   uint16 destport;
	int i;
   
   printf("Reading, buffer base %d.\r\n",buf);
   switch(getSn_SSR(s))
   {
      case SOCK_UDP:
		for(i=0;i<10;i++) {
			 if((len=getSn_RX_RSR(s)) > 0)                   /* check the size of received data */
			 {
				len = recvfrom(s,buf,len,destip,&destport);  /* receive data from a destination */
				printf("Received %d bytes from %d.%d.%d.%d(%d)\r\n",len, destip[0],destip[1],destip[2],destip[3],destport);
				printf("Buffer contents: \n");
				dump(buf,len);
				break;
			 } else {
				printf("Still trying to receive...");
				sleep(1);
			}
		}	
         break;
      case SOCK_CLOSED:                                  /* CLOSED */
         close(s);                                       /* close the SOCKET */
         break;
      default:
         break;
   }
}

void dump(uint8* buf, uint32 len) {
	uint32 i = 0;
	printf("@%d:",buf);
	for(i = 0;i< len;i++) {
		printf("%02x.",buf[i]);
	}
}
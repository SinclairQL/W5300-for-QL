#include "resolv_h"
#include "in_h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

/* Adapted from http://www.binarytides.com/blog/dns-query-code-in-c-with-winsock/ */

unsigned short readWord(unsigned char *address) {
    unsigned short value;
    value = (address[0]<<8) + address[1];
}

void send_udp(SOCKET s, uint8* buf, uint32 len)
{
 uint8 destip[4] = {192,168,0,1};
 uint16 destport = 53;

 switch(getSn_SSR(s))
 {
  case SOCK_UDP:
  if(len !=sendto(s,buf,len,destip,destport))
  {
     printf("%d : Sendto Fail.len=%d,",s,len);
     printf("%d.%d.%d.%d(%d)\r\n",destip[0],destip[1],destip[2],destip[3],destport);
 }
 break;
 default:
 printf("UDP send failed. Socket not in SOCK_UDP state. Closing socket.\n");
 close(s);
 break;
}
}

void read_udp(SOCKET s, uint8* buf, uint32 len)
{
 uint8 destip[4];
 uint16 destport;
 int i;

 switch(getSn_SSR(s))
 {
  case SOCK_UDP:
  for(i=0;i<10;i++) {
             if((len=getSn_RX_RSR(s)) > 0)                   /* check the size of received data */
   {
                len = recvfrom(s,buf,len,destip,&destport);  /* receive data from a destination */
    break;
} else {
    printf("Still waiting for answer...");
    sleep(1);
}
}
break;
      case SOCK_CLOSED:                                  /* CLOSED */
         close(s);                                       /* close the SOCKET */
break;
default:
break;
}
}

unsigned char* ReadName(unsigned char* reader,unsigned char* buffer,int* count)
{
    unsigned char *name;
    unsigned int p=0,jumped=0,offset;
    int i , j;

    *count = 1;
    name = (unsigned char*)malloc(256);

    name[0]='\0';

    /*read the names in 3www6google3com format */
    while(*reader!=0)
    {
        if(*reader>=192)
        {
            offset = (*reader)*256 + *(reader+1) - 49152; /*49152 = 11000000 00000000 ;) */
            reader = buffer + offset - 1;
            jumped = 1; /*we have jumped to another location so counting wont go up! */
        }
        else
        {
            name[p++]=*reader;
        }

        reader=reader+1;

        if(jumped==0) *count = *count + 1; /*if we havent jumped to another location then we can count up */
    }

    name[p]='\0'; /*string complete */
    if(jumped==1)
    {
        *count = *count + 1; /*number of steps we actually moved forward in the packet */
    }

    /*now convert 3www6google3com0 to www.google.com */
    for(i=0;i<(int)strlen((const char*)name);i++)
    {
        p=name[i];
        for(j=0;j<(int)p;j++)
        {
            name[i]=name[i+1];
            i=i+1;
        }
        name[i]='.';
    }

    name[i-1]='\0'; /*remove the last dot */

    return name;
}

void ChangetoDnsNameFormat(unsigned char* dns,unsigned char* host)
{
    int lock=0 , i;
    unsigned char *orig_dns;

    orig_dns = dns;
    strcat((char*)host,".");

    for(i=0 ; i<(int)strlen((char*)host) ; i++)
    {
        if(host[i]=='.')
        {
            *dns++=i-lock;
            for(;lock<i;lock++)
            {
                *dns++=host[lock];
            }
            lock++; /*or lock=i+1; */
        }
    }
    *dns++='\0';
}

void fillHeader(struct DNS_HEADER * dnsHeader) {
    dnsHeader->qr = 0; /*This is a query */
    dnsHeader->opcode = 0; /*This is a standard query */
    dnsHeader->aa = 0; /*Not Authoritative */
    dnsHeader->tc = 0; /*This message is not truncated */
    dnsHeader->rd = 1; /*Recursion Desired */
    dnsHeader->ra = 0;
    dnsHeader->z = 0;
    dnsHeader->ad = 0;
    dnsHeader->cd = 0;
    dnsHeader->rcode = 0;

    dnsHeader->id = (unsigned short)42; /*Query id of 42*/
    dnsHeader->q_count = 1; /*we have only 1 question */
    dnsHeader->ans_count = 0;
    dnsHeader->auth_count = 0;
    dnsHeader->add_count = 0;
}

void fillQuery(uint8 * dnsQueryBuffer, unsigned char *host) {
    uint8 *qname;
    struct QUESTION *qinfo;
    /*point to the query portion */
    qname =(unsigned char*)&(dnsQueryBuffer[sizeof(struct DNS_HEADER)]);
    ChangetoDnsNameFormat(qname,host);
    qinfo =(struct QUESTION*)&(dnsQueryBuffer[sizeof(struct DNS_HEADER) + (strlen((const char*)qname) + 1)]); /*fill it */
    qinfo->qtype_h = 0; /* we are requesting the ipv4 address */
    qinfo->qtype_l = 1; /* we are requesting the ipv4 address */
    qinfo->qclass_h = 0; /* internet */
    qinfo->qclass_l = 1; /* internet */
}

void sendQueryAndReceiveResponse(uint8 *buf, uint32 bufSize ,uint32 len) {
    SOCKET s = 0;  /* Number of socket to use: 0-7 */
    socket(s,Sn_MR_UDP,4224,0);
    send_udp(s, buf, len);
    read_udp(s, buf, bufSize);
    close(s);
}

uint32 findIp(uint8 * buf) {
    uint8 *answer, *qname;
    uint32 ipAddress;
    struct RES_RECORD dnsAnswer;
    struct DNS_HEADER *dns = NULL;
    int i,j,stop;

    dns = (struct DNS_HEADER *)buf;
    qname =(unsigned char*)&(buf[sizeof(struct DNS_HEADER)]);
    answer=&(buf[sizeof(struct DNS_HEADER) + (strlen((const char*)qname)+1) + sizeof(struct QUESTION)]);

    /*printf("\nThe response contains : ");
    printf("\n %d Questions.",dns->q_count);
    printf("\n %d Answers.",dns->ans_count);
    printf("\n %d Authoritative Servers.",dns->auth_count);
    printf("\n %d Additional records.\n\n",dns->add_count);
    */
    /*reading answers */
    stop=0;

    for(i=0;i<dns->ans_count;i++)
    {
        unsigned short type;

        dnsAnswer.name=ReadName(answer,buf,&stop);
        answer = answer + stop;
        dnsAnswer.resource = (struct R_DATA*)(answer);
        answer = answer + sizeof(struct R_DATA);
        type = readWord((unsigned char *)&(dnsAnswer.resource->type));
        if( type == 1) /*if its an ipv4 address */
        {
            uint8 *ipAddrPtr = (uint8 *)&ipAddress;
            for(j=0 ; j<4 ; j++) {
                uint8 num = answer[j];
                ipAddrPtr[j]=num;
            }
            return ipAddress;
        }
        else /* It's an alias name */
        {
            ReadName(answer,buf,&stop);
            answer = answer + stop;
        }
    }
    return (uint32)0;
}

uint32 ngethostbyname(unsigned char *host)
{
    uint8 *buf,*qname;
    int i , j, pton_result;
    uint32 ipv4address = 0;
    struct DNS_HEADER *dns = NULL;

    /* First check if the host string is an ip address */
    pton_result = inet_pton(AF_INET, host, (uint8 *)(&ipv4address);
        if( pton_result ) {
            return ipv4address;
        }

    /* Otherwise make a DNS query with the name */
        ipv4address = 0;
    /*Set the DNS structure to standard queries */
        buf = (uint8 *)malloc(UDP_MSG_BUF_SIZE);
        dns = (struct DNS_HEADER *)buf;
        qname =(unsigned char*)&(buf[sizeof(struct DNS_HEADER)]);
        fillHeader(dns);
        fillQuery(buf, host);
        sendQueryAndReceiveResponse(buf, UDP_MSG_BUF_SIZE, (uint32)sizeof(struct DNS_HEADER) + (strlen((const char*)qname)+1) + sizeof(struct QUESTION));
        ipv4address = findIp(buf);
        free(buf);
        return ipv4address;
    }

void initW5300() {
   uint8 tx_mem_conf[8] = {8,8,8,8,8,8,8,8};          /* for setting TMSR regsiter */
   uint8 rx_mem_conf[8] = {8,8,8,8,8,8,8,8};          /* for setting RMSR regsiter */

   uint8 ip[4] = {192,168,0,77};                   /* for setting SIP register */
   uint8 gw[4] = {192,168,0,1};                     /* for setting GAR register */
   uint8 sn[4] = {255,255,255,0};                     /* for setting SUBR register */
   uint8 mac[6] = {0x02,0x42,0x00,0x00,0x00,77};      /* locally administered mac address */

   /* initiate W5300 */
/*
   iinchip_init();
*/
   /* allocate internal TX/RX Memory of W5300 */
   if(!sysinit(tx_mem_conf,rx_mem_conf))           
   {
      printf("MEMORY CONFIG ERR.\r\n");
      exit(1);
  }

   /*setMR(getMR()|MR_FS);                            // If Little-endian, set MR_FS. */

   setSHAR(mac);                                      /* set source hardware address */
   /* configure network information */
    setGAR(gw);                                     /* set gateway IP address */
    setSUBR(sn);                                    /* set subnet mask address */
    setSIPR(ip);                                    /* set source IP address */   
}

void dump(uint8* buf, uint32 len) {
    uint32 i = 0;
    printf("@%d:",buf);
    for(i = 0;i< len;i++) {
        printf("%02x.",buf[i]);
    }
}
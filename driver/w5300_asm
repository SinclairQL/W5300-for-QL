         include  dev1_w5300_in
         include  dev1_driver_in
         include  dev2_SMS1_in
         xdef     w5300_init
         xdef     w5300_sendto_impl
         xdef     socket_open_udp
         xdef     socket_close
         section  w5300
w5300_init
         movea.l  #iobase,a1        ; A1 points to beginning of memory mapped IO space into W5300
         movea.l  a1,a0
         adda.l   #$1000,a0
         move.b   #0,(a0)           ; Reset the hardware through memory mapped write
; w5300rst ori.w    #MR_RST,MR(a1)    ; Reset W5300 through the mode register
; After reset, we need to wait for the W5300 to synchronize PLL
; According to documentation, this takes a maximum of 10ms
; @ 7.5 MHz 10 ms == 75000 clocks
; subq instruction operating on D register == 12 clocks
; bne instruction when branch taken ==  18 clocks
; Decrement, test and branch == 30 clocks => Need 2500 of these for a 10ms wait
         move.l   #2500,d0
tloop    subq.l   #1,d0
         bne      tloop
; Three step initialization process. Refer to W5300 datasheet chapter 5.1
; Step 1 *************
; 1. Mode register defaults after reset suit our purposes so no changes necessary
; 2. Host interrupts: default is no interrupts - use that for now
;
; Step 2 *************
; >>> 1. Basic network information
; Set source hardware address to a locally administered address
         move.l   #$02000042,SHAR(a1)
         move.w   #$4242,SHAR+4(a1)
; Set gateway address
         move.l   #$C0A80001,GAR(a1)         ; 192.168.0.1
; Set subnet mask
         move.l   #$FFFFFF00,SUBR(a1)        ; 255.255.255.0
; Set source IP
         move.l   #$C0A8000A,SIPR(a1)        ; 192.168.0.10
; >>> 2. Set retransmission time period and retry count
; Set RTO to 1 second (unit in RTR is 0.1 ms)
; 1s RTO is based on recommendation found in http://www.sce.carleton.ca/~nseddigh/publications/thesis-16.pdf
         move.w   #10000,RTR(a1)
; Keep the default of 8 retransmissions before giving up and closing the socket
; >>> 3. Allocate internal memory to sockets
; Keep the default 4 kb RX and 4kb TX buffer per socket
         rts
; W5300 initialization routine done
;
; Initialize a socket
; d1.b = socket #(0-7)
; Set the base address for accessing socket registers
s_init   bsr      sr_base
;
; Set socket mode to TCP/UDP
         andi.w   #S_MR_PM,S_MR(a2)
         ori.w    #S_MR_UDP,S_MR(a2)
; Set source port through a simplistic algorithm... source port == FFnn where nn = 8 bit representation of socket number
         addi.w   #$ff00,d1
         move.w   d1,S_PORTR(a2)
; Send an "open" command
         move.w   #SC_OPEN,S_CR(a2)
; Verify that the socket is in SOCK_INIT state
         bsr      s_getst
         move.w   S_SSR(a2),d0
         cmpi.b   #SS_INIT,d0
         beq.s    s_dest
         moveq    #-1,d0
         rts
; Set the destination address and port
s_dest   move.l   #$C0A80001,S_DIPR(a2)      ; 192.168.0.1
         move.w   #80,S_DPORTR(a2)
; Connect command
         move.w   #SC_CONN,S_CR(a2)
; Wait for the socket to move either to "closed" (due to ARP or TCP timeout) or "established" state
s_c_res  move.w   S_SSR(a2),d0
         beq.s    s_clsd                     ; State "0" means socket has been closed due to timeout
         cmpi.w   #SS_ESTD,d0
         bne      s_c_res
; Socket connection is now established

; Now wait for the socket to move to "initialized" state
         moveq    #0,d0
         rts
s_clsd   moveq    #err.ichn,d0                     ; -6 = invalid channel id
         rts
;
; Close a socket
; Parameters:
;  d0.b = socket number
; Returns:
;  -
; Corrupts:
;  a2
socket_close
         ext.w    d0
         bsr      sr_base                       ; a2 <= base address of socket n registers
         move.b   #SC_OPEN,S_CR1(a2)
         rts
;
; Open a UDP socket
; Parameters:
;  d0.b = socket number
;  a0 = pointer to driver definition block
; Returns:
;  d0.b = result code: -2 == socket not in closed state, -1 == not complete, 0 == success
;  a1 = address to call on the next tick if d0==-1
; Corrupts:
;  d1,d2,a2
socket_open_udp
; Check that the socket is currently in SOCK_CLOSED state
         ext.w    d0
         move.w   d0,d1
         bsr      sr_base                       ; a2 <= base address of socket n registers
         move.b   S_SSR1(a2),d2
         cmpi.b   #SS_CLSD,d2
         bne.s    socket_not_closed_err
; Set socket mode to UDP
         andi.w   #S_MR_PM,S_MR(a2)
         ori.w    #S_MR_UDP,S_MR(a2)
; Send an "open" command
         move.b   #SC_OPEN,S_CR1(a2)
; Wait for W5300 to acknowledge command by resetting command register to 0
udp_open_check_cmd_ack
         move.b   S_CR1(a2),d2
         cmpi.b   #0,d2
         beq.s    udp_open_wait_state_udp
         lea      udp_open_check_cmd_ack,a1
         move.l   a2,CHAN_REG_STORE(a0)         ; Store pointer to socket register block
         move.l   (a7),CHAN_REG_STORE+4(a0)   ; Store return address
         moveq    #ERR_NC,d0
         rts
udp_open_wait_state_udp
; Wait for socket to move to state SOCK_UDP
         move.b   S_SSR1(a2),d2
; TODO: testing, switch to correct implementation below on real HW
;         cmpi.b   #0,d2
         cmpi.b   #SS_UDP,d2
         beq.s    udp_open_ok
         lea      udp_open_wait_state_udp,a1
         move.l   a2,CHAN_REG_STORE(a0)         ; Store pointer to socket register block
         move.l   (a7),CHAN_REG_STORE+4(a0)   ; Store return address
         moveq    #ERR_NC,d0
         rts
udp_open_ok
         moveq    #0,d0
         rts
socket_not_closed_err
         moveq    #-2,d0
         rts
;
; Parameters:
;  d0.w = # of bytes to write
;  d1.b = socket #
;  d2.l = destination ip
;  d3.w = destination port
;  a1 = buffer address
;
w5300_sendto_impl
         bsr.s    sr_base                                ; a2 := socket memory address base
         bsr      socket_set_dest
         bsr      socket_write_bytes                     ; d2 = # bytes to write, a1 = buffer address
         move.w   d0,S_TX_WS2(a2)
         move.b   #SC_SEND,S_CR1(a2)
         rts
;
; Set destination for socket
; Parameters:
;  d1.b = socket #
;  d2.l = destination ip
;  d3.q = destination port
; Corrupts:
;  a2
;
socket_set_dest
         bsr.s    sr_base        ; a2 = base address of socket registers
         move.l   d2,S_DIPR(a2)
         move.w   d3,S_DPORTR(a2)
         rts
;
; Write bytes to a socket
; Parameters:
;  d1.b = socket #
;  d2.w = number of bytes to write
;  a1 = pointer to buffer of bytes to write
; Returns:
;  d0.w = number of bytes written
;
socket_write_bytes
; N.B we can't know if the buffer is aligned on a word boundary!
         bsr.s    sr_base                       ; a2 := socket register base
         move.l   a1,d7
         btst     #0,d7
         beq.s    write_word_aligned            ; Buffer is word-aligned
; Write from a non-aligned buffer using bytes-sized operations
         subq.w   #1,d2
write_byte_sized_loop
         move.b   (a1)+,S_TXFIFO(a2)
         move.b   (a1)+,S_TXFIFO+1(a2)
         dbra     d2,write_byte_sized_loop
         rts
write_word_aligned
         asr.w    #1,d2
         bcs.s    w_wloop
         subq.w   #1,d2
w_wloop  move.w   (a3)+,S_TXFIFO(a2)
         dbf      d2,w_wloop
         rts
;
;
; Subroutine to get socket state, socket register base address passed in a2
; Returns current socket state in d0
s_getst  move.w   S_SSR(a2),d0
         cmpi.b   #SS_INIT,d0
         rts
;
; Find base address for a socket's registers and return it in a2
; Parameters:
;        d1.b     number of socket (0-7)
; Returns:
;        a2.l     base address of register bank for socket number passed in d1
; Corrupts:
;        d7

sr_base  movea.l  #iobase+S_BASE,a2
         ext.w    d1
         move.w   d1,d7
         mulu     #S_SIZE,d7
         adda.w   d7,a2
         rts
;;
;;        w_rdbuf reads number of bytes from socket n to buffer
;;        parameters:
;;        d1.b     number of socket (0-7)
;;        d2.w     number of bytes to read CORRUPTED
;;        a1       pointer to buffer area. Needs to be a multiple of two bytes since data is read
;;                 from W5300 in word sized operations
;;        corrupts:
;;        a2,a3
;;        d2
;;
;
; We are reading in word sized numbers so the number of read operations is
; number of bytes div 2 (+1 if odd number of bytes)
; since we are looping with dbf d2 will contain number of loops - 1
;
w_rdbuf  asr.w    #1,d2
         bcs.s    wrb_odd
         subq.w   #1,d2
; Get the base address of this socket's registers into a2
wrb_odd  bsr      sr_base
         movea.l  a1,a3
w_rdloop move.w   S_RXFIFO(a2),(a3)+
         dbf      d2,w_rdloop
         rts
         end

         in       dev1_driver_in
; Get QDOS info to get sysvars address in a0
         moveq    #0,d0
         trap     #1
; >>> Allocate storage for driver from common heap <<<
; Sysvars address passed in A6, save old A6
         move.l   a6,-(a7)
         movea.l  a0,a6
         move.l   #HEAP_SIZE,d1     ; Number of bytes required
; MM_ALCHP has to be called in supervisor mode
         trap     #0                ; Enter supervisor mode
         movea.w  MM_ALCHP,a4
         jsr      (a4)
; Return to user mode (== clear bit 13 of status register)
         andi     #$DFFF,sr
         bne      oom_exit
; On successful return from MM_ALCHP, A0 points to start of allocated area
; First 4 bytes of the allocated area contains the size of the heap fragment and should be preserved
; Set up the driver linkage (standard version) block
         movea.l  (a7)+,a6
         lea      4(a0),a1
         adda.l   #$1C,a1
         lea      channel_IO,a2
         move.l   a2,(a1)+
         lea      open_channel,a2
         move.l   a2,(a1)+
         lea      close_channel,a2
         move.l   a2,(a1)
         adda.l   #$1C,a0             ; Point to $18 (==link to next driver) past the start of linkage block
         moveq    #MT_LIOD,d0         ; link in this driver
         trap     #1
         tst.b    d0
         bne      direct_exit
; Set up SuperBasic keywords
         lea      KEYWORDS,a1
         move.w   BP_INIT,a4     ; Vector to link in new procedures and functions
         jsr      (a4)
         rts
;
oom_exit
         movea.l  (a7)+,a6
direct_exit
         rts
;
QE_UNLOAD
         move.b   #IO_SSTRG,d0    ; Write unload notification message on channel #0
         move.l   #24,d2           ; Length of message
         moveq    #0,d3           ; Timeout == 0
         movea.l  #0,a0           ; channel id of channel 0
         lea      msg_unload,a1
         trap     #3
; Open a SCK_ channel so that we can get a reference to the address of the driver linkage block
; by calling a TRAP #3 IO-routine
         moveq    #IO_OPEN,d0
         moveq    #-1,d1         ; Current job owns the channel
         moveq    #0,d3          ; Regular open
         lea      chan_name_sck,a0
         trap     #2
         tst.b    d0
         bne      unload_exit
; Channel id is now in A0, correct for trap #3 calls
; QE_IO_DRV_INFO returns pointer to start of driver definition block in a1
         move.b   #QE_IO_DRV_INFO,d0
         moveq    #-1,d3         ; Timeout
         trap     #3
         move.l   a1,-(a7)       ; Save the result
; Close the channel, a0 containing channel id has been preserved in the previous trap
         moveq    #IO_CLOSE,d0
         trap     #2
; Get QDOS info to get sysvars address in a0, sysvars needed in A6 for MM_RECHP
         moveq    #0,d0
         trap     #1
; Sysvars address passed in A6, save old A6
         move.l   a6,-(a7)
         movea.l  a0,a6
         movea.l  4(a7),a0
         adda.l   #$18,a0
         moveq    #MT_RIOD,d0          ; remove link to this driver, preserves a0
         trap     #1
         suba.l   #$1C,a0              ; Move pointer to start of heap allocation block
         trap     #0                   ; Release heap needs to be called in supervisor mode
         movea.w  MM_RECHP,a4
         jsr      (a4)
; Return to user mode (== clear bit 13 of status register)
         andi     #$DFFF,sr
; Reset a6 to original value
         movea.l  (a7),a6
         adda.l   #8,a7                ; remove sysvars + driver block pointer from stack
         moveq    #0,d0
unload_exit
         rts
msg_unload
         dc.b    'Unloading W5300 driver.',10
chan_name_sck
         dc.w     4
         dc.b    'SCK_'
;
NSLOOKUP
; Check that the function was called with one parameter
         lea      8(a3),a0
         cmpa.l   a0,a5
         bne      bad_param
         movea.w  CA_GTSTR,a4
         jsr      (a4)
         bne      bad_param      ; Verify that the parameter was a string
; Echo the parameter to channel #0
         move.b   #IO_SSTRG,d0   ;
         move.w   0(a6,a1.l),d2  ; Length of string
         moveq    #0,d3          ; Timeout == 0
         movea.l  #0,a0          ; channel id of channel 0
         lea      2(a6,a1.l),a1  ; Pointer to start of string
         trap     #3
; Update math stack pointer, consume string from the stack, make sure we consume an even number of bytes
         move.w   d2,d3          ; Save original value
         andi.b   #1,d2
         beq      nslookup_update_math_stack
         addq.w   #1,d3          ; If string length was odd, add one to consume even number of bytes
nslookup_update_math_stack
         addq.b   #2,d3          ; Account for the string length word on the stack
         add.l    d3,BV_RIP(a6)
         moveq    #10,d1         ; Number of bytes on the maths stack needed for the return value
         move.w   BV_CHRIX,a4    ; Vector to make sure required space is available on the maths stack
         jsr      (a4)           ; No error status is returned on QDOS!
         move.l   BV_RIP(a6),a1  ; Load maths stack head pointer
         suba.l   #10,a1          ; Move the top of maths stack by length of string + length word
         move.l   a1,BV_RIP(a6)  ; Save the updated BV_RIP pointer to tell QDOS where to pick up the return value
         move.w   #7,0(a6,a1.l)  ; Length of return string
         move.l   #'0.0.',2(a6,a1.l)
         move.l   #'0.0X',6(a6,a1.l)
         moveq    #1,d4          ; Return a string
         moveq    #0,d0          ; No errors
         rts
bad_param
         move.b   #ERR_BP,d0
         rts
;
open_channel
         movea.l  a0,a2
         move.w   (a2)+,d1
         cmpi.w   #4,d1
         bcs      notme   
         move.l   (a2)+,d2
         and.l    #$dfdfdfff,d2     ; Uppercase the first three characters
         cmpi.l   #'SCK_',d2
         bne      notme
; reserve space for the channel definition block
; save A0 in case memory allocation fails
         move.l   a0,-(a7)
         move.l   #$40,d1
; A6 already points to sysvars when handling a trap #3
; Also, we are already in supervisor mode, which is a prerequisite for MM_ALCHP
         movea.w  MM_ALCHP,a4
         jsr      (a4)
         bne      open_channel_fail
         adda.l   #4,a7             ; purge saved a0 from stack
; a0 contains pointer to allocated channel definition block with $0(a0).w containing length of definition block
         rts
open_channel_fail
         movea.l  (a7)+,a0
         rts
close_channel
         movea.w  MM_RECHP,a4
         jsr      (a4)
         rts
channel_IO
         cmpi.b   #QE_IO_DRV_INFO,d0
         beq      driver_info
         moveq    #0,d0
         rts
driver_info
         movea.l  a3,a1
         moveq    #0,d0
         rts
; Set up the serio pointers area
         lea      ptrs,a0
         lea      io_ready,a2
         move.l   a2,(a0)+
         lea      fetch,a2
         move.l   a2,(a0)+
         lea      send,a2
         move.l   a2,(a0)
; Set up the driver linkage (standard version) block
         lea      lnkblk+$1C,a0
         lea      IO,a2
         move.l   a2,(a0)+
         lea      open,a2
         move.l   a2,(a0)+
         lea      close,a2
         move.l   a2,(a0)
         lea      lnkblk+$18,a0
         moveq    #mt_liod,d0        ; link in this driver
         trap     #1
         bne      bad_exit
;         bsr      init_w5
         bra      io_ready
; Remove driver from chain
         lea      lnkblk+$18,a0
         moveq    #mt_riod,d0        ; remove this driver
         trap     #1
         bra      io_ready
lnkblk   ds.l     $40
udpname  dc.w     'UDP'
; Insert W5300 code
;         in       mdv3_w5300_asm
; Insert driver name parser
         in       dev1_parser_asm
pop_notme
         adda.w   #6,a7             ; Ditch saved string length (word) and pointer to start of string (long word)   
notme
         moveq    #-7,d0            ; "not found" == driver name does not match
         rts
open     movea.l  a0,a2
         move.w   (a2)+,d1
         cmpi.w   #4,d1
         bcs      notme   
         move.l   (a2)+,d2
         and.l    #$dfdfdfff,d2     ; Uppercase the first three characters
         cmpi.l   #'UDP_',d2
         bne      notme
         subq.w   #4,d1             ; Four characters have been read from driver name, update length remaining
         move.w   d1,-(a7)          
         move.l   a2,-(a7)
         move.w   d1,d4                             ; Length of string to d4
         movea.l  a2,a1                             ; Pointer to first character after udp_
         bsr      read_ip_address                     ; updates d4
         beq      ip_address_known
         move.w   4(a7),d4
         movea.l  (a7),a1
         bsr      resolve_host_name
         bne      pop_notme
ip_address_known
         cmpi.w   #2,d4                               ; There should be at least two more characters for ':' + port number
         blt      pop_notme
         move.b   (a1)+,d1
         cmpi.b   #':',d1
         bne      pop_notme
         subq.w   #1,d4                               ; Account for the ':' that was read
         bsr      rdnum
         bne      pop_notme
         adda.w   #6,a7             ; Ditch saved string length (.w) and pointer to start of string (.l)
         move.l   #$40,d1           ; reserve space for the channel definition block
         movea.w  mm_alchp,a4
         move.l   a0,-(a7)          ; Save the A0 from entry to open just in case the allocation fails
         jsr      (a4)
         bne      ra0ext
         addq.l   #4,a7             ; Ditch the saved A0, we won't need it any more
         move.l   #$20000,$22(a0)    ; Set up the screen buffer as the memory area this driver writes/reads
; Save ip address and port in driver linkage block
         move.l   d7,$18(a0)        ; ip address
         move.w   d2,$1c(a0)
         bra      io_ready
ra0ext   move.l   (a7)+,a0          ; Restore A0 and exit
         rts
close    movea.w  mm_rechp,a4
         jmp      (a4)
IO       movea.w  io_serio,a4        ; Deal with trap #3 . .
         jsr      (a4)               ; . . calls by IO.SERIO
*
* These three pointers are to:
*
*         io ready - here does nothing
*         fetch a byte to D1
*         send a byte from D1
*
* NOTE D1 has to end up containing the current position of the file
*      which is at $22(A0)
*
ptrs     ds.l     3
         rts
*
fetch
         movea.l   $22(a0),a1
         move.b    (a1),d1            ; Set the next byte to D1.B
fetch_1  addq.l    #1,$22(a0)         ; Increment the current address
io_ready moveq     #0,d0
bad_exit rts
*
send
         movea.l   $22(a0),a1
         move.b    d1,(a1)
         bra       fetch_1
KEYWORDS dc.w     1             ; No of procedures we are linking in
         dc.w     QE_UNLOAD-*   ; Pointer to code of first procedure
         dc.b     9,'QE_UNLOAD' ; Name of first procedure
         dc.w     0             ; End marker for procedures
         dc.w     1             ; No of functions we are linking in
         dc.w     NSLOOKUP-*    ; Pointer to code of first function
         dc.b     9,'NSLOOKUP$' ; Name of first function
         dc.w     0             ; End marker for functions

         in       dev1_resolv_macros_asm
         in       dev1_driver_in
; Get QDOS info to get sysvars address in a0
         moveq    #0,d0
         trap     #1
; >>> Allocate storage for driver from common heap <<<
; This storage area will also include a user heap to be used for temporary storage needs
;
; MM_ALCHP has to be called in supervisor mode
         trap     #0                ; Enter supervisor mode
; Sysvars address need to be passed in A6, save old A6 that Superbasic has set (safe, because we are in supervisor mode)
         move.l   a6,-(a7)
         movea.l  a0,a6
         move.l   #HEAP_SIZE,d1     ; Number of bytes required for all memory needs of this driver + associated keywords
         movea.w  MM_ALCHP,a4
         jsr      (a4)
         movea.l  (a7)+,a6            ; Restore original SuperBasic A6
; Return to user mode (== clear bit 13 of status register)
         andi     #$DFFF,sr
         bne      oom_exit
; On successful return from MM_ALCHP, A0 points to start of allocated area
; First 4 bytes of the allocated area contains the size of the heap fragment and should be preserved
; Set up the driver linkage (standard version) block
         lea      4(a0),a1
         adda.l   #$1C,a1
         lea      channel_IO,a2
         move.l   a2,(a1)+
         lea      open_channel,a2
         move.l   a2,(a1)+
         lea      close_channel,a2
         move.l   a2,(a1)
         adda.l   #$1C,a0             ; Point to $18 (==link to next driver) past the start of linkage block
         moveq    #MT_LIOD,d0         ; link in this driver
         trap     #1
         tst.b    d0
         bne      direct_exit
         suba.l   #$18,a0             ; Reset A0 to point to start of linkage block
         move.l   a0,-(a7)             ; And save it for later
; Set up a user heap for temporary storage needs
         lea      QE_MEM_UH_PTR(a0),a1       ; Pointer to heap header
         move.l   0,(a1)                     ; Indicate this is a new heap
         suba.l   a6,a1                      ; Needs to be relative A6
         lea      QE_MEM_USER_HEAP(a0),a0    ; Start of user heap area
         move.l   #USER_HEAP_SIZE,d1         ; Number of bytes reserved for the user heap
         suba.l   a6,a0                      ; We need A0 to be A6 relative
         move.b   #MT_LNKFR,d0               ; Trap code
         trap     #1                         ; This trap doesn't report errors
; Set up SuperBasic keywords
         lea      KEYWORDS,a1
         move.w   BP_INIT,a4     ; Vector to link in new procedures and functions
         jsr      (a4)
         bsr      w5300_init                 ; Reset and set up the ethernet card
; Restore pointer to linkage blck
         movea.l  (a7)+,a0
; Initialize socket reservation table - all sockets are not reserved
         lea      QE_MEM_SOCK_RT(a0),a1      ; Start of socket reservation table
         move.w   #NUM_SOCKETS,d0
         subq.w   #1,d0
sock_res_table_init_loop
         move.l   #SOCK_RT_STAT_FREE,(a1)+   ; Mark the socket as not reserved
         dbra     d0,sock_res_table_init_loop
         moveq    #0,d0
         rts
;
oom_exit
         movea.l  (a7)+,a6
direct_exit
         rts
; Reserve a socket
; a0: pointer to channel definition block, used as reservation identifier
; a3: pointer to driver definition block
; Returns:
; D0 : 0-7 == number of socket reserved for the channel, FF == no sockets available
;
reserve_socket
         lea      QE_MEM_SOCK_RT_END(a3),a1         ; Pointer to one past last entry in the table
         moveq    #NUM_SOCKETS-1,d0
reserve_socket_loop
         cmpi.l   #SOCK_RT_STAT_FREE,-(a1)
         beq      reserve_socket_found
         dbra     d0,reserve_socket_loop
reserve_socket_exit
         rts
reserve_socket_found
         move.l   a0,(a1)
         rts
; Release a socket
; a0: pointer to channel definition block
; a3: pointer to driver definition block
; d0: number of socket to release
release_socket
         cmpi.b   #NUM_SOCKETS-1,d0
         bhi      invalid_socket_number
         ext.w    d0
         lsl.w    #2,d0
         lea      QE_MEM_SOCK_RT(a3,d0.w),a1
         move.l   (a1),d1
         cmpa.l   d1,a0
         bne      illegal_socket_reservation
         move.l   #SOCK_RT_STAT_FREE,(a1)
         moveq    #0,d0
         rts
invalid_socket_number
         moveq    #-1,d0
         rts
illegal_socket_reservation
         moveq    #-2,d0
         rts
;
open_sck_channel
         moveq    #IO_OPEN,d0
         moveq    #-1,d1         ; Current job owns the channel
         moveq    #0,d3          ; Regular open
         lea      chan_name_sck,a0
         trap     #2
         rts                     ; Return channel id in a0, error code in d0
; Parameters: A0 == channel id of SCK_ channel
close_sck_channel
         moveq    #IO_CLOSE,d0
         trap     #2
         rts
; get_driver_info: utility routine to ask the w5300 driver where its driver linkage block resides
; This allows client SuperBasic functions/procedures to gain access to memory reserved by the driver
; Parameters
; Entry: a0 = channel id of SCK_ channel
; Corrupts: d0,d1,d3,a1,a1
; Returns: A1 = pointer to start of driver definition block
get_driver_info
; QE_IO_DRV_INFO returns pointer to start of driver definition block in a1
         move.b   #QE_IO_DRV_INFO,d0
         moveq    #-1,d3         ; Timeout
         trap     #3
         tst.b    d0
         bne      get_driver_info_exit
get_driver_info_exit
         rts
;
; Allocate user heap
; Parameters:
; d1 : number of bytes required
; a0 : user heap free space handle
; Returns:
; a0 : pointer to allocated heap block
; d0 : error code (0 == no error)
; Corrupts:
; A0-A3, D0-D3
allocate_user_heap
         moveq    #MT_ALLOC,d0         ; Trap code
         suba.l   a6,a0                ; Make the pointer relative to A6
         trap     #1
         tst.l    d0                   ; Did it work ?
         beq.s    user_heap_alloc_ok
         rts
user_heap_alloc_ok
         adda.l   a6,a0                ; The address we get back is relative A6, so absolute it
         rts
;
; Deallocate user heap
; Parameters:
; a0 : pointer to start of allocated block (starting with the long word containing block size)
; a1 : user heap free space handle
; Returns:
; nothing, LNKFR does not report errors!
; Corrupts:
; A0-A3, D0-D3
deallocate_user_heap
         moveq    #MT_LNKFR,d0            ; Trap code
         move.l   0(a0),d1                ; Size of block to be released
         suba.l   a6,a0                   ; A0 has to be relative a6
         suba.l   a6,a1                   ; Free space handle also has to be relative A6
         trap     #1                      ; Deallocate the 200 byte area
         rts
QE_UNLOAD
         move.b   #IO_SSTRG,d0    ; Write unload notification message on channel #0
         move.l   #24,d2           ; Length of message
         moveq    #0,d3           ; Timeout == 0
         movea.l  #0,a0           ; channel id of channel 0
         lea      msg_unload,a1
         trap     #3
         bsr      open_sck_channel
         tst.b    d0
         bne      unload_exit
         move.l   a0,-(a7)
         bsr      get_driver_info
         tst.b    d0
         bne      unload_exit
         move.l   a1,-(a7)       ; Save the result
; Get QDOS info to get sysvars address in a0, sysvars needed in A6 for MM_RECHP
         moveq    #0,d0
         trap     #1
; Sysvars address passed in A6, save old A6
         move.l   a6,-(a7)
         movea.l  a0,a6
         movea.l  4(a7),a0
         adda.l   #$18,a0
         moveq    #MT_RIOD,d0          ; remove link to this driver, preserves a0
         trap     #1
         suba.l   #$1C,a0              ; Move pointer to start of heap allocation block
         trap     #0                   ; Release heap needs to be called in supervisor mode
         movea.w  MM_RECHP,a4
         jsr      (a4)
; Return to user mode (== clear bit 13 of status register)
         andi     #$DFFF,sr
; Reset a6 to original value
         movea.l  (a7),a6
         adda.l   #8,a7                ; remove sysvars + driver block pointer from stack
         movea.l  (a7)+,a0
         bsr      close_sck_channel
         moveq    #0,d0
unload_exit
         rts
msg_unload
         dc.b    'Unloading W5300 driver.',10
chan_name_sck
         dc.w     4
         dc.b    'SCK_'
;
NSLOOKUP
; Check that the function was called with one parameter
         lea      8(a3),a0
         cmpa.l   a0,a5
         beq      nslookup_num_params_ok
         moveq    #ERR_BP,d0
         rts
nslookup_num_params_ok
         movea.w  CA_GTSTR,a4
         jsr      (a4)
         tst.l    d0
         beq      nslookup_string_param_ok
         moveq    #ERR_BP,d0
         rts
nslookup_string_param_ok
; Verify that the name is not longer than the maximum length of 254 characters == 255 octets DNS label encoded
         move.w   0(a6,a1.l),d2  ; Length of string
         cmpi.w   #DNS_MAX_NAME_LEN,d2
         bls      nslookup_check_null_name
         moveq    #ERR_BP,d0
         rts
nslookup_check_null_name
         tst.w    d2
         bne      nslookup_param_ok       ; Don't accept an empty string
         moveq    #ERR_BP,d0
         rts
nslookup_param_ok
         link     a5,#-NSL_LOCAL_VARS_SIZE    ; Allocate space on stack for local variables, a5 becomes frame pointer (FP)
         lea      2(a6,a1.l),a1              ; Pointer to start of string
         move.l   a1,NSL_NAMEPTR(a5)         ; Save pointer in local frame
         move.w   d2,NSL_W_NAMELEN(a5)       ; Save length of string
; Open SCK_ channel to get driver info and netdb access
         bsr      open_sck_channel
         tst.b    d0
         beq      nslookup_get_driver_info
         unlk     a5
         moveq    #ERR_NF,d0
         rts
nslookup_get_driver_info
         move.l   a0,NSL_SCK_CHANNEL(a5)
         bsr      get_driver_info            ; Set A1 = pointer to driver linkage block
         tst.b    d0
         beq      nslookup_driver_info_ok
         move.b   #ERR_NF,-(a7)
         bra      exit_close_sck
nslookup_driver_info_ok
         move.l   a1,NSL_DRVLBPTR(a5)        ; Save pointer to linkage block
; Allocate temporary buffer for hostname on user heap
         move.w   NSL_W_NAMELEN(a5),d1       ; Length of string from stack
         addq.w   #1,d1                      ; Add one for the terminating null that will be appended
         addq.w   #8,d1                      ; Add user heap block book keeping overhead
         movea.l  NSL_DRVLBPTR(a5),a1
         lea      QE_MEM_UH_PTR(a1),a0
         bsr      allocate_user_heap         ; A1 = ptr to driver linkage block, d1 = required size
; A0 now contains pointer to start of allocated block if return status == 0
         tst.b    d0
         beq      allocate_struct_hostent_buffer
         move.b   #ERR_OM,-(a7)
         bra      exit_close_sck
allocate_struct_hostent_buffer
         move.l   a0,NSL_NAMEBUFPTR(a5)
         move.w   #STRUCT_HE_SIZE+HOSTENT_BUF_SIZE,d1          ; Size of temporary struct bufent and associated data
         addq.w   #8,d1                                        ; Add user heap block book keeping overhead
         movea.l  NSL_DRVLBPTR(a5),a1                          ; Pointer go start of linkage block
         lea      QE_MEM_UH_PTR(a1),a0
         bsr      allocate_user_heap                           ; A1 = ptr to driver linkage block, d1 = required size
; A0 now contains pointer to start of allocated block if return status == 0
         tst.b    d0
         beq      copy_hostname_to_temp_buffer
; struct hostent allocation failed, clean up and exit
; Unallocate temp hostname buffer
         move.b   #ERR_OM,-(a7)
         bra      exit_unallocate_name_buf_close_sck
; Copy the hostname to temporary buffer in the driver's linkage block
; A0 -> user heap temp block
; D2 == length of hostname string on maths stack
; A2 -> start of hostname string on maths stack
copy_hostname_to_temp_buffer
         move.l   a0,NSL_STRUCT_HE_BUF(a5)
         movea.l  NSL_NAMEBUFPTR(a5),a0
         move.w   NSL_W_NAMELEN(a5),d0
         movea.l  NSL_NAMEPTR(a5),a2
         lea      8(a0),a4       ; First 8 bytes are allocation block book keeping info
         subq.w   #1,d0          ; For dbra looping dn needs to be num_loops-1
nslookup_name_copy_loop
         move.b   (a2)+,(a4)+
         dbra     d0,nslookup_name_copy_loop
; Terminate the string with a C-style end of string marker
         move.b   #0,(a4)
; Call gethostbyname
         moveq    #IP_GETHOSTBYNAME,d0
         moveq    #50,d3                  ; Timeout, -1 == wait for as long as it takes
         movea.l  NSL_SCK_CHANNEL(a5),a0
         movea.l  NSL_NAMEBUFPTR(a5),a1
         adda.l   #8,a1                      ; Skip over heap block book keeping info
         movea.l  NSL_STRUCT_HE_BUF(a5),a2
         adda.l   #8,a2                      ; Skip over heap block book keeping info
         trap     #3
         move.b   d0,-(a7)                   ; Save exit status
         bne      nslookup_exit_deallocate
; Call succeeded, 
; Update math stack pointer, consume string from the stack, make sure we consume an even number of bytes
         clr.l    d2
         move.w   NSL_W_NAMELEN(a5),d2
         btst     #0,d2
         beq      nslookup_update_math_stack
         addq.w   #1,d2          ; If string length was odd, add one to consume even number of bytes
nslookup_update_math_stack
         addq.b   #2,d2          ; Account for the string length word on the stack
         add.l    d2,BV_RIP(a6)
; Call inet_ntoa to get a (C-style null-terminated) ascii version of ip address, use math stack as result buffer
         moveq    #IP_INET_NTOA,d0
         moveq    #0,d3                  ; Timeout, -1 == wait for as long as it takes
         movea.l  NSL_SCK_CHANNEL(a5),a0
         movea.l  STRUCT_HE_HADDRLIST(a2),a3       ; a3 now points to A table
         movea.l  (a3),a1                          ; Pointer to first ip address in return struct
         lea      NSL_IP_STRING_BUF(a5),a2
         trap     #3
         lea      NSL_IP_STRING_BUF(a5),a0
         bsr      strlen
         moveq    #0,d1
         move.w   d0,d1
         move.w   d0,d4          ; Save original
         btst     #0,d1
         beq      ipstrlen_even
         addq.l   #1,d1
ipstrlen_even
         addq.l   #2,d1          ; Space for length word
         move.l   d1,d5          ; Save stack allocation length, d1 is corrupted (on Minerva) when calling BV_CHRIX
         move.l   BV_RIP(a6),a1
         move.w   BV_CHRIX,a4    ; Vector to make sure required space is available on the maths stack, d1==required bytes
         jsr      (a4)           ; No error status is returned on QDOS!
         move.l   BV_RIP(a6),a1  ; Load maths stack head pointer
         suba.l   d5,a1
         move.l   a1,BV_RIP(a6)
         move.w   d4,0(a6,a1.l)
         addq.l   #2,a1
         subq.l   #2,d5
         lea      NSL_IP_STRING_BUF(a5),a0
nslookup_ip_string_copy_loop
         move.w   (a0)+,d0
         move.w   d0,0(a6,a1.l)
         addq.l   #2,a1
         subq.l   #2,d5
         tst.l    d5
         bne      nslookup_ip_string_copy_loop
nslookup_exit_deallocate
; Deallocate space reserved on the user heap
         movea.l  NSL_STRUCT_HE_BUF(a5),a0
         movea.l  NSL_DRVLBPTR(a5),a1
         lea      QE_MEM_UH_PTR(a1),a1
         bsr      deallocate_user_heap
exit_unallocate_name_buf_close_sck
         movea.l  NSL_NAMEBUFPTR(a5),a0
         movea.l  NSL_DRVLBPTR(a5),a1
         lea      QE_MEM_UH_PTR(a1),a1
         bsr      deallocate_user_heap
exit_close_sck
         movea.l  NSL_SCK_CHANNEL(a5),a0
         bsr      close_sck_channel
exit_pop_and_unlink
         clr.l    d0
         move.b   (a7)+,d0
         bne      exit_unlink
         moveq    #1,d4                         ; Return a string
exit_unlink
         ext.w    d0
         ext.l    d0
         unlk     a5
         rts
;
open_channel
         movea.l  a0,a2
         move.w   (a2)+,d1
         cmpi.w   #4,d1
         bcs      notme   
         move.l   (a2)+,d2
         and.l    #$dfdfdfff,d2     ; Uppercase the first three characters
         cmpi.l   #'SCK_',d2
         bne      notme
; reserve space for the channel definition block
; save A0 in case memory allocation fails
         move.l   a0,-(a7)
         move.l   #$80,d1
; A6 already points to sysvars when handling a trap #3
; Also, we are already in supervisor mode, which is a prerequisite for MM_ALCHP
         movea.w  MM_ALCHP,a4
         jsr      (a4)
         bne      open_channel_fail
         adda.l   #4,a7             ; purge saved a0 from stack
; a0 contains pointer to allocated channel definition block with $0(a0).w containing length of definition block
;
; Initialize driver-specific storage in channel def block
         move.l   #0,CHAN_CONT_ADDR(a0)   ; Clear continuation address
         rts
notme
         moveq    #-7,d0            ; "not found" == driver name does not match
         rts
;
open_channel_fail
         movea.l  (a7)+,a0
         rts
close_channel
         movea.w  MM_RECHP,a4
         jsr      (a4)
         rts
channel_IO
         lea      CHAN_LOCAL_VARS(a0),a5
         cmpi.b   #0,d3                      ; D3==0 if first call, D3==-1 if re-entering a not-complete call
         beq      channel_IO_check_operation
         cmpi.l   #0,CHAN_CONT_ADDR(a0)      ; Check if the chan def block contains a continuation address
         beq      channel_IO_check_operation ; If it was 0 then we don't have a continuation address
         movea.l  CHAN_REG_STORE(a0),a2      ; Restore A2 (TODO: set of registers)
         move.l   CHAN_REG_STORE+4(a0),d1    ; Return address to push on to the stack
         move.l   d1,-(a7)
         movea.l  CHAN_CONT_ADDR(a0),a1
         move.l   #0,CHAN_CONT_ADDR(a0)      ; Reset continuation so that we don't call it again
         jmp      (a1)
channel_IO_check_operation
         cmpi.b   #QE_IO_DRV_INFO,d0
         beq      driver_info
         cmpi.b   #IP_GETHOSTBYNAME,d0
         beq      ip_gethostbyname_impl
         cmpi.b   #IP_INET_ATON,d0
         beq      ip_inet_aton_impl
         cmpi.b   #IP_INET_NTOA,d0
         beq      ip_inet_ntoa_impl
         moveq    #0,d0
         rts
driver_info
         movea.l  a3,a1
         moveq    #0,d0
         rts
; Provides gethostbyname(2) functionality
;
;    Input
;
;    D0 = IP_GETHOSTBYNAME
;    D3 = (short) timeout (-1)
;
;    A0 = (chanid_t *) channel ID
;         A1 = (char *) name       // NULL terminated
;         A2 = (struct hostent *)hostent buffer   // minimum of 500 bytes
;
; The buffer pointed to by A2 must be at large enough to hold the
; largest struct hostent returned.
;
;    D0 = result
;
ip_gethostbyname_impl
         move.l   a0,IO_CHANDB(a5)
         move.l   a3,IO_DRVDB(a5)
         move.l   a6,IO_SYSVARS(a5)
         move.l   a1,IO_HOSTNAME_PTR(a5)
         move.l   a2,IO_STRUCT_HE_PTR(a5)
         lea      STRUCT_HE_HADDRLIST(a2),a2
         bsr      ip_inet_aton_impl                ; Returns ip address in d7 if successful
         tst.b    d0
         bne      lookup_hostname
         movea.l  IO_HOSTNAME_PTR(a5),a1
         movea.l  IO_STRUCT_HE_PTR(a5),a2
         bsr      hostent_init
         move.l   d7,d0
         bsr      hostent_add_ip
         movea.l  IO_CHANDB(a5),a0
         moveq    #0,d0
         rts
; TODO implement socket layer. Now uses a static fake response.
lookup_hostname
; Reserve a socket
         movea.l  IO_CHANDB(a5),a0
         movea.l  IO_DRVDB(a5),a3
         bsr      reserve_socket
; TODO check error
         move.w   d0,IO_SOCK_NUM(a5)
; Create and fill in a DNS query packet. For now, release it after creating it
         movea.l  IO_HOSTNAME_PTR(a5),a0
         movea.l  a0,a4
         bsr      strlen
         movea.l  IO_DRVDB(a5),a3
         lea      QE_MEM_UH_PTR(a3),a0
         bsr      create_dns_query_buffer
         move.l   a2,IO_DNS_QUERY_BUF_PTR(a5)
         tst.b    d0
         bne      create_dummy_response
; Open a UDP socket for the query
         move.w   IO_SOCK_NUM(a5),d0
         movea.l  IO_CHANDB(a5),a0
         bsr      socket_open_udp
         tst.b    d0
         beq      release_query_block
         cmpi.b   #ERR_NC,d0
         bne      release_query_block
         move.l   a1,CHAN_CONT_ADDR(a0)
         bra      lookup_hostname_exit
; Release the DNS query heap block
release_query_block
         movea.l  IO_DNS_QUERY_BUF_PTR(a5),a0
         suba.l   #8,a0                      ; Point to beginning of allocated user heap block
         movea.l  IO_DRVDB(a5),a3
         lea      QE_MEM_UH_PTR(a3),a1
         bsr      deallocate_user_heap
create_dummy_response
         movea.l  IO_HOSTNAME_PTR(a5),a1
         movea.l  IO_STRUCT_HE_PTR(a5),a2
         bsr      hostent_init
         lea      DNS_DUMMY_RESPONSE,a3
         movea.l  a2,a0                      ; a0 now points to struct hostent
         move.l   a5,-(a7)                   ; Save frame pointer
         bsr      get_ip_from_dns_response   ; WIP: Try to fill in hostent from dns response
         movea.l  (a7)+,a5
; Close and release the reserved socket
         movea.l  IO_CHANDB(a5),a0
         movea.l  IO_DRVDB(a5),a3
         move.w   IO_SOCK_NUM(a5),d0
; Close the socket
; TODO: how to close and release when operation does not complete within the allocated timeout??!!
         bsr      socket_close
         bsr      release_socket
; TODO check error
         moveq    #0,d0
; Exit with whatever code is in d0
lookup_hostname_exit
         movea.l  IO_CHANDB(a5),a0
         rts
;
; Initialize a struct hostent with a host name passed in
; Parameters:
;     A1: pointer to null-terminated host name string
;     A2: pointer to struct hostent
hostent_init
         lea      STRUCT_HE_SIZE(a2),a3
         move.l   a3,STRUCT_HE_HNAME(a2)
         move.l   a2,-(a7)
         movea.l  a3,a2
         move.w   #DNS_MAX_NAME_LEN,d0
         bsr      strncpy
         move.l   a2,d1                         ; On return, A2 points at one byte past the string terminating null byte
         move.l   (a7)+,a2                      ; Restore pointer to struct hostent
         btst     #0,d1
         beq      hostent_init_set_haddrlist
         addq.l   #1,d1
hostent_init_set_haddrlist
         move.l   d1,STRUCT_HE_HADDRLIST(a2)
         movea.l  d1,a3
         move.l   #0,(a3)
         move.l   #AF_INET,STRUCT_HE_HADDRTYPE(a2)       ; Only IPv4 supported so this is fixed
         move.l   #AF_INET_ADDR_LEN,STRUCT_HE_HLEN(a2)   ; Number of bytes per address (==4)
         rts
; DEPRECATED, TODO: remove Add an ip address to a struct hostent
; PREREQUISITE: struct hostent has been initialized so that the ip address list pointer is valid
; Parameters:
;     A2: pointer to a struct hostent buffer with sufficient space
;     D0.l ip address to add
;
hostent_add_ip
         movea.l  STRUCT_HE_HADDRLIST(a2),a3
; 0-7 = table of address pointers (1 entry + terminator), 8-11 = null terminator for alias table
         lea      12(a3),a4
         move.l   a4,(a3)+
         move.l   d0,(a4)
         clr.l    (a3)+
         move.l   a3,STRUCT_HE_HALIASES(a2)
         clr.l    (a3)
         rts
; Copy at most n bytes from one string to another
; Always terminates the target with a null byte so can use n+1 bytes of target buffer
; Parameters:
;     A1: pointer to null-terminated string to copy from
;     A2: pointer to pre-allocated buffer to copy to
;     D0.w: maximum number of bytes to copy (excluding terminating null byte)
; Returns:
;     D0.w  number of bytes copied (excluding terminating null)
strncpy
         cmp.w    #0,d0
         bhi      strncpy_maxlen_ok
         move.b   #0,(a2)+
         rts
strncpy_maxlen_ok
         move.w   #0,d2
         subq.w   #1,d0       ; Subtract one to make correct # of loops using dbra
strncpy_copy_loop
         addq.w   #1,d2
         move.b   (a1)+,d1
         move.b   d1,(a2)+
         beq      strncpy_string_end
         dbra     d0,strncpy_copy_loop
         move.b   #0,(a2)+
strncpy_string_end
         move.w   d2,d0
         rts
; Strlen - return number of characters in a c-style null-terminated string
; A0: pointer to start of string
; Returns:
; D0.w: length of string
strlen
         moveq    #0,d0
strlen_loop
         move.b   (a0)+,d1
         beq      strlen_exit
         addq.w   #1,d0
         bra      strlen_loop
strlen_exit
         rts
;
; IP_INET_ATON
;
; Provides inet_aton(2) functionality
;
;    Input
;
;         D0 = IP_INET_ATON;
;         D3 = (short) timeout (-1)
;    A0 = (chanid_t) channel ID
;         A1 = (char *) name
;         A2 = ( struct in_addr *)inaddr buffer
;
;    Output
;
;    D0 = result
;
ip_inet_aton_impl
         move.l   a0,-(a7)             ; Save channel id
         movea.l  a1,a0
         bsr      strlen               ; Get string length in d0, a0 = pointer to string
         moveq    #0,d4
         move.w   d0,d4
         bsr      read_ip_address
         movea.l  (a7)+,a0
         rts
;
;IP_INET_NTOA
;
;Provides inet_ntoa(2) functionality
;
;   Input
;
;   D0 = IP_INET_NTOA
;   D3 = (short) timeout (-1)
;   A0 = (chanid_t) channel ID
;   A1 = (struct in_addr *) net address buffer
;   A2 = (char *) result buffer
;
;   Output
;
;   D0 = result
ip_inet_ntoa_impl
         move.l   a0,-(a7)             ; Need to preserve channel id
         move.l   (a1),d0
         movea.l  a2,a0
         bsr      long_to_ip_string
         movea.l  (a7)+,a0
         moveq    #0,d0
         rts
long_to_ip_string
         rol.l   #8,d0
         bsr     byte_to_string
         move.b  #'.',(a0)+
         rol.l   #8,d0
         bsr     byte_to_string
         move.b  #'.',(a0)+
         rol.l   #8,d0
         bsr     byte_to_string
         move.b  #'.',(a0)+
         rol.l   #8,d0
         bsr     byte_to_string
         move.b  #0,(a0)+
         rts
byte_to_string
         moveq   #0,d1
         moveq   #0,d2           ; Clear flag register
         move.b  d0,d1
         divu    #100,d1
         tst.w   d1
         beq     byte_to_string_handle_tens
         add.b   #$30,d1
         move.b  d1,(a0)+
         moveq   #1,d2           ; Flag to tell we have hundreds
byte_to_string_handle_tens
         clr.w   d1
         swap    d1              ; Remainder to lower word
         divu    #10,d1
         tst.b   d2
         bne     byte_to_string_have_hundreds   ; There are non-zero hundreds so we can print a potential zero
         tst.w   d1
         beq     byte_to_string_handle_ones
byte_to_string_have_hundreds
         add.b   #$30,d1
         move.b  d1,(a0)+
byte_to_string_handle_ones
         swap    d1
         add.b   #$30,d1
         move.b  d1,(a0)+
         rts
; Insert parser utility functions
         in       dev1_parser_asm
         in       dev1_resolv_asm
; Insert W5300 code
         in       dev1_w5300_asm
KEYWORDS dc.w     2             ; No of procedures we are linking in
         dc.w     QE_UNLOAD-*   ; Pointer to code of first procedure
         dc.b     9,'QE_UNLOAD' ; Name of first procedure
         dc.w     0             ; End marker for procedures
         dc.w     2             ; No of functions we are linking in
         dc.w     NSLOOKUP-*    ; Pointer to code of first function
         dc.b     9,'NSLOOKUP$' ; Name of first function
         dc.w     0             ; End marker for functions
; Wireshark capture of DNS query response to www.lekane.net
DNS_DUMMY_RESPONSE
         dc.l     $00068180,$00010005,$00000000,$03777777,$066c656b,$616e6503,$6e657400,$00010001
         dc.l     $c00c0005,$00010000,$012b0015,$1270726f,$642d6575,$77312d64,$69616c6f,$677565c0
         dc.l     $10c02c00,$05000100,$00003b00,$0e0b7061,$62303230,$2d657577,$31c010c0,$4d000500
         dc.l     $01000001,$2b003416,$70616230,$32302d65,$7577312d,$32303732,$38343839,$36310965
         dc.l     $752d7765,$73742d31,$03656c62,$09616d61,$7a6f6e61,$77730363,$6f6d00c0,$67000100
         dc.l     $01000000,$3b000436,$f6c85fc0,$67000100,$01000000,$3b000436
         dc.b     $ab,$e1,$bf

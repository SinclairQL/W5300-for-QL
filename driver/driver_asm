         in       dev1_driver_in
; Get QDOS info to get sysvars address in a0
         moveq    #0,d0
         trap     #1
; >>> Allocate storage for driver from common heap <<<
; This storage area will also include a user heap to be used for temporary storage needs
;
; MM_ALCHP has to be called in supervisor mode
         trap     #0                ; Enter supervisor mode
; Sysvars address need to be passed in A6, save old A6 that Superbasic has set (safe, because we are in supervisor mode)
         move.l   a6,-(a7)
         movea.l  a0,a6
         move.l   #HEAP_SIZE,d1     ; Number of bytes required for all memory needs of this driver + associated keywords
         movea.w  MM_ALCHP,a4
         jsr      (a4)
         movea.l  (a7)+,a6            ; Restore original SuperBasic A6
; Return to user mode (== clear bit 13 of status register)
         andi     #$DFFF,sr
         bne      oom_exit
; On successful return from MM_ALCHP, A0 points to start of allocated area
; First 4 bytes of the allocated area contains the size of the heap fragment and should be preserved
; Set up the driver linkage (standard version) block
         lea      4(a0),a1
         adda.l   #$1C,a1
         lea      channel_IO,a2
         move.l   a2,(a1)+
         lea      open_channel,a2
         move.l   a2,(a1)+
         lea      close_channel,a2
         move.l   a2,(a1)
         adda.l   #$1C,a0             ; Point to $18 (==link to next driver) past the start of linkage block
         moveq    #MT_LIOD,d0         ; link in this driver
         trap     #1
         tst.b    d0
         bne      direct_exit
         suba.l   #$18,a0             ; Reset A0 to point to start of linkage block
; Set up a user heap for temporary storage needs
         lea      QE_MEM_UH_PTR(a0),a1       ; Pointer to heap header
         move.l   0,(a1)                     ; Indicate this is a new heap
         suba.l   a6,a1                      ; Needs to be relative A6
         lea      QE_MEM_USER_HEAP(a0),a0    ; Start of user heap area
         move.l   #USER_HEAP_SIZE,d1         ; Number of bytes reserved for the user heap
         suba.l   a6,a0                      ; We need A0 to be A6 relative
         move.b   #MT_LNKFR,d0               ; Trap code
         trap     #1                         ; This trap doesn't report errors
; Set up SuperBasic keywords
         lea      KEYWORDS,a1
         move.w   BP_INIT,a4     ; Vector to link in new procedures and functions
         jsr      (a4)
         rts
;
oom_exit
         movea.l  (a7)+,a6
direct_exit
         rts
;
open_sck_channel
         moveq    #IO_OPEN,d0
         moveq    #-1,d1         ; Current job owns the channel
         moveq    #0,d3          ; Regular open
         lea      chan_name_sck,a0
         trap     #2
         rts                     ; Return channel id in a0, error code in d0
; Parameters: A0 == channel id of SCK_ channel
close_sck_channel
         moveq    #IO_CLOSE,d0
         trap     #2
         rts
; get_driver_info: utility routine to ask the w5300 driver where its driver linkage block resides
; This allows client SuperBasic functions/procedures to gain access to memory reserved by the driver
; Parameters
; Entry: a0 = channel id of SCK_ channel
; Corrupts: d0,d1,d3,a1,a1
; Returns: A1 = pointer to start of driver definition block
get_driver_info
; QE_IO_DRV_INFO returns pointer to start of driver definition block in a1
         move.b   #QE_IO_DRV_INFO,d0
         moveq    #-1,d3         ; Timeout
         trap     #3
         tst.b    d0
         bne      get_driver_info_exit
get_driver_info_exit
         rts
;
; Allocate user heap
; Parameters:
; d1 : number of bytes required
; a1 : pointer to start of driver linkage block
; Returns:
; a0 : pointer to allocated heap block
; d0 : error code (0 == no error)
; Corrupts:
; A0-A3, D0-D3
allocate_user_heap
         moveq    #MT_ALLOC,d0         ; Trap code
         lea      QE_MEM_UH_PTR(a1),a0 ; pointer to pointer to user heap
         suba.l   a6,a0                ; Make the pointer relative to A6
         trap     #1
         tst.l    d0                   ; Did it work ?
         beq.s    user_heap_alloc_ok
         rts
user_heap_alloc_ok
         adda.l   a6,a0                ; The address we get back is relative A6, so absolute it
         rts
;
; Deallocate user heap
; Parameters:
; a0 : pointer to start of allocated block (starting with the long word containing block size)
; a1 : pointer to start of driver linkage block
; Returns:
; nothing, LNKFR does not report errors!
; Corrupts:
; A0-A3, D0-D3
deallocate_user_heap
         moveq    #MT_LNKFR,d0            ; Trap code
         move.l   0(a0),d1                ; Size of block to be released
         suba.l   a6,a0                   ; A0 has to be relative a6
         lea      QE_MEM_UH_PTR(a1),a1
         suba.l   a6,a1                   ; Which has also to be relative A6
         trap     #1                      ; Deallocate the 200 byte area
         rts
QE_UNLOAD
         move.b   #IO_SSTRG,d0    ; Write unload notification message on channel #0
         move.l   #24,d2           ; Length of message
         moveq    #0,d3           ; Timeout == 0
         movea.l  #0,a0           ; channel id of channel 0
         lea      msg_unload,a1
         trap     #3
         bsr      open_sck_channel
         tst.b    d0
         bne      unload_exit
         move.l   a0,-(a7)
         bsr      get_driver_info
         tst.b    d0
         bne      unload_exit
         move.l   a1,-(a7)       ; Save the result
; Get QDOS info to get sysvars address in a0, sysvars needed in A6 for MM_RECHP
         moveq    #0,d0
         trap     #1
; Sysvars address passed in A6, save old A6
         move.l   a6,-(a7)
         movea.l  a0,a6
         movea.l  4(a7),a0
         adda.l   #$18,a0
         moveq    #MT_RIOD,d0          ; remove link to this driver, preserves a0
         trap     #1
         suba.l   #$1C,a0              ; Move pointer to start of heap allocation block
         trap     #0                   ; Release heap needs to be called in supervisor mode
         movea.w  MM_RECHP,a4
         jsr      (a4)
; Return to user mode (== clear bit 13 of status register)
         andi     #$DFFF,sr
; Reset a6 to original value
         movea.l  (a7),a6
         adda.l   #8,a7                ; remove sysvars + driver block pointer from stack
         movea.l  (a7)+,a0
         bsr      close_sck_channel
         moveq    #0,d0
unload_exit
         rts
msg_unload
         dc.b    'Unloading W5300 driver.',10
chan_name_sck
         dc.w     4
         dc.b    'SCK_'
;
NSLOOKUP
; Check that the function was called with one parameter
         lea      8(a3),a0
         cmpa.l   a0,a5
         beq      nslookup_num_params_ok
         move.b   #ERR_BP,d0
         bra      exit_with_error
nslookup_num_params_ok
         movea.w  CA_GTSTR,a4
         jsr      (a4)
         tst.l    d0
         beq      nslookup_string_param_ok
         move.b   #ERR_BP,d0
         bra      exit_with_error      ; Verify that the parameter was a string
nslookup_string_param_ok
; Verify that the name is not longer than the maximum length of 254 characters == 255 octets DNS label encoded
         move.w   0(a6,a1.l),d2  ; Length of string
         cmpi.w   #DNS_MAX_NAME_LEN,d2
         bls      nslookup_check_null_name
         move.b   #ERR_BP,d0
         bra      exit_update_RIP
nslookup_check_null_name
         tst.w    d2
         bne      nslookup_param_ok       ; Don't accept an empty string
         move.b   #ERR_BP,d0
         bra      exit_update_RIP
nslookup_param_ok
         link     a5,#-NSL_LOCAL_VARS_SIZE    ; Allocate space on stack for local variables, a5 becomes frame pointer (FP)
         lea      2(a6,a1.l),a1              ; Pointer to start of string
         move.l   a1,NSL_NAMEPTR(a5)         ; Save pointer in local frame
         move.w   d2,NSL_W_NAMELEN(a5)       ; Save length of string
         bsr      open_sck_channel
         tst.b    d0
         bne      nslookup_exit_driver_info
         move.l   a0,NSL_SCK_CHANNEL(a5)
         bsr      get_driver_info            ; Set A1 = pointer to driver linkage block
         tst.b    d0
         beq      nslookup_driver_info_ok
nslookup_exit_driver_info
         unlk     a5
         move.b   #ERR_NF,d0
         bra      exit_close_sck_update_RIP
nslookup_driver_info_ok
         move.l   a1,NSL_DRVLBPTR(a5)        ; Save pointer to linkage block
         move.w   NSL_W_NAMELEN(a5),d1       ; Length of string from stack
         addq.w   #1,d1                      ; Add one for the terminating null that will be appended
         bsr      allocate_user_heap         ; A1 = ptr to driver linkage block, d1 = required size
; A0 now contains pointer to start of allocated block if return status == 0
         tst.b    d0
         beq      allocate_struct_hostent_buffer
         unlk     a5
         move.b   #ERR_OM,d0
         bra      exit_close_sck_update_RIP
allocate_struct_hostent_buffer
         move.l   a0,NSL_NAMEBUFPTR(a5)
         move.w   #STRUCT_HE_SIZE+HOSTENT_BUF_SIZE,d1          ; Size of temporary struct bufent and associated data
         movea.l  NSL_DRVLBPTR(a5),a1                          ; Pointer go start of linkage block
         bsr      allocate_user_heap                           ; A1 = ptr to driver linkage block, d1 = required size
; A0 now contains pointer to start of allocated block if return status == 0
         tst.b    d0
         beq      copy_hostname_to_temp_buffer
; struct hostent allocation failed, clean up and exit
; Unallocate temp hostname buffer
         movea.l  NSL_NAMEBUFPTR(a5),a0
         movea.l  NSL_DRVLBPTR(a5),a1
         bsr      deallocate_user_heap
         unlk     a5
         move.b   #ERR_OM,d0
         bra      exit_close_sck_update_RIP
; Copy the hostname to temporary buffer in the driver's linkage block
; A0 -> user heap temp block
; D2 == length of hostname string on maths stack
; A2 -> start of hostname string on maths stack
copy_hostname_to_temp_buffer
         move.l   a0,NSL_STRUCT_HE_BUF(a5)
         movea.l  NSL_NAMEBUFPTR(a5),a0
         move.w   NSL_W_NAMELEN(a5),d0
         movea.l  NSL_NAMEPTR(a5),a2
         lea      4(a0),a4       ; First 4 bytes are allocation block size
         subq.w   #1,d0          ; For dbra looping dn needs to be num_loops-1
nslookup_name_copy_loop
         move.b   (a2)+,(a4)+
         dbra     d0,nslookup_name_copy_loop
; Terminate the string with a C-style end of string marker
         move.b   #0,(a4)
; TODO call gethostbyname
; Close SCK_ channel
         movea.l  NSL_SCK_CHANNEL(a5),a0
         bsr      close_sck_channel
; Deallocate space reserved on the user heap
         movea.l  NSL_STRUCT_HE_BUF(a5),a0
         movea.l  NSL_DRVLBPTR(a5),a1
         bsr      deallocate_user_heap
         movea.l  NSL_NAMEBUFPTR(a5),a0
         movea.l  NSL_DRVLBPTR(a5),a1
         bsr      deallocate_user_heap
; Update math stack pointer, consume string from the stack, make sure we consume an even number of bytes
         clr.l    d2
         move.w   NSL_W_NAMELEN(a5),d2
         btst     #0,d2
         beq      nslookup_update_math_stack
         addq.w   #1,d2          ; If string length was odd, add one to consume even number of bytes
nslookup_update_math_stack
         addq.b   #2,d2          ; Account for the string length word on the stack
         add.l    d2,BV_RIP(a6)
         moveq    #10,d1         ; Number of bytes on the maths stack needed for the return value
         move.w   BV_CHRIX,a4    ; Vector to make sure required space is available on the maths stack
         jsr      (a4)           ; No error status is returned on QDOS!
         move.l   BV_RIP(a6),a1  ; Load maths stack head pointer
         suba.l   #10,a1          ; Move the top of maths stack by length of string + length word
         move.l   a1,BV_RIP(a6)  ; Save the updated BV_RIP pointer to tell QDOS where to pick up the return value
         move.w   #7,0(a6,a1.l)  ; Length of return string
         move.l   #'0.0.',2(a6,a1.l)
         move.l   #'0.0X',6(a6,a1.l)
         moveq    #1,d4          ; Return a string
         moveq    #0,d0          ; No errors
         unlk     a5
         rts
exit_close_sck_update_RIP
         move.l   d0,-(a7)                   ; Save error value
         movea.l  NSL_SCK_CHANNEL(a5),a0
         bsr      close_sck_channel
         move.l   (a7)+,d0
         move.w   NSL_W_NAMELEN(a5),d2       ; Load length of string
exit_update_RIP
; Entered with length of string in d2
         btst     #0,d2
         beq      exit_update_math_stack
         addq.w   #1,d2          ; If string length was odd, add one to consume even number of bytes
exit_update_math_stack
         addq.b   #2,d2          ; Add 2 to account for the string length word on the stack
         add.l    d2,BV_RIP(a6)
exit_with_error
; Error code should be in d0
         rts
;
open_channel
         movea.l  a0,a2
         move.w   (a2)+,d1
         cmpi.w   #4,d1
         bcs      notme   
         move.l   (a2)+,d2
         and.l    #$dfdfdfff,d2     ; Uppercase the first three characters
         cmpi.l   #'SCK_',d2
         bne      notme
; reserve space for the channel definition block
; save A0 in case memory allocation fails
         move.l   a0,-(a7)
         move.l   #$40,d1
; A6 already points to sysvars when handling a trap #3
; Also, we are already in supervisor mode, which is a prerequisite for MM_ALCHP
         movea.w  MM_ALCHP,a4
         jsr      (a4)
         bne      open_channel_fail
         adda.l   #4,a7             ; purge saved a0 from stack
; a0 contains pointer to allocated channel definition block with $0(a0).w containing length of definition block
         rts
notme
         moveq    #-7,d0            ; "not found" == driver name does not match
         rts

open_channel_fail
         movea.l  (a7)+,a0
         rts
close_channel
         movea.w  MM_RECHP,a4
         jsr      (a4)
         rts
channel_IO
         cmpi.b   #QE_IO_DRV_INFO,d0
         beq      driver_info
         cmpi.b   #IP_GETHOSTBYNAME,d0
         beq      ip_gethostbyname_impl
         moveq    #0,d0
         rts
driver_info
         movea.l  a3,a1
         moveq    #0,d0
         rts
; Provides gethostbyname(2) functionality
;
;    Input
;
;    D0 = IP_GETHOSTBYNAME
;    D3 = (short) timeout (-1)
;
;    A0 = (chanid_t *) channel ID
;         A1 = (char *) name       // NULL terminated
;         A2 = (struct hostent *)hostent buffer   // minimum of 500 bytes
;
; The buffer pointed to by A2 must be at large enough to hold the
; largest struct hostent returned.
;
;    D0 = result
;
ip_gethostbyname_impl
         nop
         moveq    #0,d0
         rts
; Insert W5300 code
;         in       mdv3_w5300_asm
; Insert driver name parser
;         in       dev1_parser_asm
KEYWORDS dc.w     2             ; No of procedures we are linking in
         dc.w     QE_UNLOAD-*   ; Pointer to code of first procedure
         dc.b     9,'QE_UNLOAD' ; Name of first procedure
         dc.w     0             ; End marker for procedures
         dc.w     2             ; No of functions we are linking in
         dc.w     NSLOOKUP-*    ; Pointer to code of first function
         dc.b     9,'NSLOOKUP$' ; Name of first function
         dc.w     0             ; End marker for functions

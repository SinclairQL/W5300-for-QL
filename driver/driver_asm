         include  'dev1_driver_in'
         include  'dev2_qdos1_in'
;         include  'dev2_sms1_in'
         include  'dev2_sms3_in'
         include  'dev2_sms17_in'
		xdef		allocate_user_heap
		xdef		deallocate_user_heap
		xdef		_init_driver
;
		xref		w5300_init
		xref		w5300_socket
		xref		w5300_connect
		xref		w5300_send_impl
		xref		w5300_sendto_impl
		xref		w5300_recvfrom_impl
		xref		w5300_recv_bytes_available
		xref		w5300_send_bytes_available
		xref		socket_close
		xref		create_dns_query_buffer
		xref		socket_open_udp
		xref		get_ip_from_dns_response
		xref		read_ip_address
		xref		_nslookup_impl
		section		driver
_init_driver
; Save regs that C68 needs
		movem.l   a4-a5,-(a7)
; Get QDOS info to get sysvars address in a0
         moveq    #0,d0
         trap     #1
; Example of how to call a C function
;		 move.l   #42,-(a7)
;		 lea      _foo,a4
;		 jsr 	  (a4)
;		 move.l   (a7)+,d1
; >>> Allocate storage for driver from common heap <<<
; This storage area will also include a user heap to be used for temporary storage needs
;
; MM_ALCHP has to be called in supervisor mode
         trap     #0                ; Enter supervisor mode
; Sysvars address need to be passed in A6, save old A6 that Superbasic has set (safe, because we are in supervisor mode)
         move.l   a6,-(a7)
         movea.l  a0,a6
         move.l   #HEAP_SIZE,d1     ; Number of bytes required for all memory needs of this driver + associated keywords
         movea.w  mem.achp,a4
         jsr      (a4)
         movea.l  (a7)+,a6            ; Restore original SuperBasic A6
; Return to user mode (== clear bit 13 of status register)
         andi.w   #$DFFF,sr
         bne.s    oom_exit
; On successful return from MM_ALCHP, A0 points to start of allocated area
; First 4 bytes of the allocated area contains the size of the heap fragment and should be preserved
; Set up the driver linkage (standard version) block
         lea      4(a0),a1
         adda.l   #$1C,a1
         lea      channel_IO,a2
         move.l   a2,(a1)+
         lea      open_channel,a2
         move.l   a2,(a1)+
         lea      close_channel,a2
         move.l   a2,(a1)
         adda.l   #$1C,a0             ; Point to $18 (==link to next driver) past the start of linkage block
         moveq    #MT.LIOD,d0         ; link in this driver
         trap     #1
         tst.b    d0
         bne.s    direct_exit
         suba.l   #$18,a0             ; Reset A0 to point to start of linkage block
         move.l   a0,-(a7)             ; And save it for later
; Set up a user heap for temporary storage needs
         lea      QE_MEM_UH_PTR(a0),a1       ; Pointer to heap header
         move.l   0,(a1)                     ; Indicate this is a new heap
         suba.l   a6,a1                      ; Needs to be relative A6
         lea      QE_MEM_USER_HEAP(a0),a0    ; Start of user heap area
         move.l   #USER_HEAP_SIZE,d1         ; Number of bytes reserved for the user heap
         suba.l   a6,a0                      ; We need A0 to be A6 relative
         move.b   #MT.LNKFR,d0               ; Trap code
         trap     #1                         ; This trap doesn't report errors
; Set up SuperBasic keywords
         lea      KEYWORDS,a1
         move.w   sb.inipr,a4                ; Vector to link in new procedures and functions
         jsr      (a4)
         bsr      w5300_init                 ; Reset and set up the ethernet card
; Restore pointer to linkage blck
         movea.l  (a7)+,a0
; Initialize socket reservation table - all sockets are not reserved
         lea      QE_MEM_SOCK_RT(a0),a1      ; Start of socket reservation table
         move.w   #NUM_SOCKETS,d0
         subq.w   #1,d0
sock_res_table_init_loop
         move.l   #SOCK_RT_STAT_FREE,(a1)+   ; Mark the socket as not reserved
         dbra     d0,sock_res_table_init_loop
		movem.l 	(a7)+,a4-a5
         moveq    #0,d0
         rts
;
oom_exit
         movea.l  (a7)+,a6
direct_exit
		movem.l 	(a7)+,a4-a5
         rts

; Reserve a socket
; a0: pointer to channel definition block, used as reservation identifier
; a3: pointer to driver definition block
; Returns:
; D0 : 0-7 == number of socket reserved for the channel, FF == no sockets available
;
reserve_socket
         lea      QE_MEM_SOCK_RT_END(a3),a1         ; Pointer to one past last entry in the table
         moveq    #NUM_SOCKETS-1,d0
reserve_socket_loop
         cmpi.l   #SOCK_RT_STAT_FREE,-(a1)
         beq.s    reserve_socket_found
         dbra     d0,reserve_socket_loop
reserve_socket_exit
         rts
reserve_socket_found
         move.l   a0,(a1)
         rts
; Release a socket
; a0: pointer to channel definition block
; a3: pointer to driver definition block
; d0: number of socket to release
release_socket
         cmpi.b   #NUM_SOCKETS-1,d0
         bhi.s    invalid_socket_number
         ext.w    d0
         lsl.w    #2,d0
         lea      QE_MEM_SOCK_RT(a3,d0.w),a1
         move.l   (a1),d1
         cmpa.l   d1,a0
         bne.s    illegal_socket_reservation
         move.l   #SOCK_RT_STAT_FREE,(a1)
         moveq    #0,d0
         rts
invalid_socket_number
         moveq    #-1,d0
         rts
illegal_socket_reservation
         moveq    #-2,d0
         rts
;
; Find a reserved socket based on pointer to channel definition block
; Parameters:
;  a0: pointer to channel definition block
;  a3: pointer to driver definition block
; Returns:
;  d0: -1 if no sockets reserved for this socket, 0-7 indicates a socket # reserved for the channel
;
find_socket_reservation
         lea      QE_MEM_SOCK_RT_END(a3),a1         ; Pointer to one past last entry in the table
         moveq    #NUM_SOCKETS-1,d0
find_socket_loop
         cmpa.l   -(a1),a0
         beq.s    reserved_socket_found
         dbra     d0,find_socket_loop
         rts            ; D0 == -1
reserved_socket_found
         rts      ; D0 contains socket number (0-7)
;
open_sck_channel
         moveq    #IO.OPEN,d0
         moveq    #-1,d1         ; Current job owns the channel
         moveq    #0,d3          ; Regular open
         lea      chan_name_sck,a0
         trap     #2
         rts                     ; Return channel id in a0, error code in d0
; Parameters: A0 == channel id of SCK_ channel
close_sck_channel
         moveq    #IO.CLOSE,d0
         trap     #2
         rts
; get_driver_info: utility routine to ask the w5300 driver where its driver linkage block resides
; This allows client SuperBasic functions/procedures to gain access to memory reserved by the driver
; Parameters
; Entry: a0 = channel id of SCK_ channel
; Corrupts: d0,d1,d3,a1,a1
; Returns: A1 = pointer to start of driver definition block
get_driver_info
; QE_IO_DRV_INFO returns pointer to start of driver definition block in a1
         move.b   #QE_IO_DRV_INFO,d0
         moveq    #-1,d3         ; Timeout
         trap     #3
; Return whatever exit code the trap returns
         rts
;
; Allocate user heap
; Parameters:
; d1 : number of bytes required
; a0 : user heap free space handle
; Returns:
; a0 : pointer to allocated heap block
; d0 : error code (0 == no error)
; Corrupts:
; A0-A3, D0-D3
allocate_user_heap
         moveq    #MT.ALLOC,d0         ; Trap code
         suba.l   a6,a0                ; Make the pointer relative to A6
         trap     #1
         tst.l    d0                   ; Did it work ?
         beq.s    user_heap_alloc_ok
         rts
user_heap_alloc_ok
         adda.l   a6,a0                ; The address we get back is relative A6, so absolute it
         rts
;
; Deallocate user heap
; Parameters:
; a0 : pointer to start of allocated block (starting with the long word containing block size)
; a1 : user heap free space handle
; Returns:
; nothing, LNKFR does not report errors!
; Corrupts:
; A0-A3, D0-D3
deallocate_user_heap
         moveq    #MT.LNKFR,d0            ; Trap code
         move.l   0(a0),d1                ; Size of block to be released
         suba.l   a6,a0                   ; A0 has to be relative a6
         suba.l   a6,a1                   ; Free space handle also has to be relative A6
         trap     #1                      ; Deallocate the 200 byte area
         rts
QE_UNLOAD
         move.b   #IO.SSTRG,d0    ; Write unload notification message on channel #0
         move.l   #24,d2           ; Length of message
         moveq    #0,d3           ; Timeout == 0
         movea.l  #0,a0           ; channel id of channel 0
         lea      msg_unload,a1
         trap     #3
         bsr      open_sck_channel
         tst.b    d0
         bne.s    unload_exit
         move.l   a0,-(a7)
         bsr      get_driver_info
         tst.b    d0
         bne.s    unload_exit
         move.l   a1,-(a7)       ; Save the result
; Get QDOS info to get sysvars address in a0, sysvars needed in A6 for MM_RECHP
         moveq    #0,d0
         trap     #1
; Sysvars address passed in A6, save old A6
         move.l   a6,-(a7)
         movea.l  a0,a6
         movea.l  4(a7),a0
         adda.l   #$18,a0
         moveq    #MT.RIOD,d0          ; remove link to this driver, preserves a0
         trap     #1
         suba.l   #$1C,a0              ; Move pointer to start of heap allocation block
         trap     #0                   ; Release heap needs to be called in supervisor mode
         movea.w  mem.rchp,a4
         jsr      (a4)
; Return to user mode (== clear bit 13 of status register)
         andi.w   #$DFFF,sr
; Reset a6 to original value
         movea.l  (a7),a6
         adda.l   #8,a7                ; remove sysvars + driver block pointer from stack
         movea.l  (a7)+,a0
         bsr      close_sck_channel
         moveq    #0,d0
unload_exit
         rts
msg_unload
         dc.b    'Unloading W5300 driver.',10
chan_name_sck
         dc.w     4
         dc.b    'SCK_'
;
NSLOOKUP
; Check that the function was called with one parameter
         lea      8(a3),a0
         cmpa.l   a0,a5
         beq.s    nslookup_num_params_ok
         moveq    #err.bp,d0
         rts
nslookup_num_params_ok
         movea.w  sb.gtstr,a4
         jsr      (a4)
         tst.l    d0
         beq.s    nslookup_string_param_ok
         moveq    #err.bp,d0
         rts
nslookup_string_param_ok
; Verify that the name is not longer than the maximum length of 254 characters == 255 octets DNS label encoded
         move.w   0(a6,a1.l),d2  ; Length of string
         cmpi.w   #DNS_MAX_NAME_LEN,d2
         bls.s    nslookup_check_null_name
         moveq    #err.bp,d0
         rts
nslookup_check_null_name
         tst.w    d2
         bne.s    nslookup_param_ok       ; Don't accept an empty string
         moveq    #err.bp,d0
         rts
nslookup_param_ok
         lea      0(a6,a1.l),a1              ; Pointer to start of (QL-style) string
		movem.l 	d0-d3/a0-a5,-(a7)
; Call C implementation
		 move.l   a1,-(a7)
		 lea      _nslookup_impl,a4
		 jsr 	  (a4)
		 move.l   d0,d4 					; Store result
		 clr.l 		(a7)+ 					; Remove the parameter that was passed to function from stack
		movem.l 	(a7)+,d0-d3/a0-a5
; Call succeeded, 
; Update math stack pointer, consume string from the stack, make sure we consume an even number of bytes
; d2 should still contain length of string
         btst     #0,d2
         beq.s    nslookup_update_math_stack
         addq.w   #1,d2          ; If string length was odd, add one to consume even number of bytes
nslookup_update_math_stack
         addq.b   #2,d2          ; Account for the string length word on the stack
         add.l    d2,BV_RIP(a6)  ; update math stack pointer

         moveq.l  #6,d1 		 ; How many bytes on math stack
         move.l   BV_RIP(a6),a1
         move.w   qa.resri,a4    ; Vector to make sure required space is available on the maths stack, d1==required bytes
         jsr      (a4)           ; No error status is returned on QDOS!
         move.l   BV_RIP(a6),a1  ; Load maths stack head pointer
         suba.l   #6,a1
         move.l   a1,BV_RIP(a6)
		 
		 ; put result on math stack, can't return long so we have to do float trickery
		 move.w 	#$81f,0(a6,a1.l) ; Exponent is offset by $81f so this means mantissa*2^(81f-81f)
; Result is stored in 32-bit mantissa and can be printed with TK II function hex$(x,32)
         move.l 	d4,2(a6,a1.l)
         moveq    	#2,d4                         ; Return a floating point (==6 byte value)
		 moveq 		#0,d0
         rts
;
; Allocate a new source port number for a socket
; Parameters:
;  d1.b = socket #
;  a0 = driver definition block
;  a6 = sysvars
; Returns:
;  d0.w = source port number
;
new_source_port
         ext.w    d1
         move.w   SV_RAND(a6),d0
         lsl.w    #3,d0
         add.w    d1,d0
         rts
;
open_channel
         movea.l  a0,a2
         move.w   (a2)+,d1
         cmpi.w   #4,d1
         bcs.s    notme   
         move.l   (a2)+,d2
         and.l    #$dfdfdfff,d2     ; Uppercase the first three characters
         cmpi.l   #'SCK_',d2
         beq.s    open_channel_alloc_mem
         cmpi.l   #'TCP_',d2
         beq.s    open_channel_alloc_mem
         cmpi.l   #'UDP_',d2
         beq.s    open_channel_alloc_mem
         bra.s    notme
open_channel_alloc_mem
         move.l   d2,d6             ; Save channel name
; reserve space for the channel definition block
; save A0 in case memory allocation fails
         move.l   a0,-(a7)
         move.l   #$80,d1
; A6 already points to sysvars when handling a trap #3
; Also, we are already in supervisor mode, which is a prerequisite for MM_ALCHP
         movea.w  mem.achp,a4
         jsr      (a4)
         bne.s    open_channel_fail
         adda.l   #4,a7             ; purge saved a0 from stack
; a0 contains pointer to allocated channel definition block with $0(a0).w containing length of definition block
         cmpi.l   #'SCK_',d6        ; For netdb access, don't reserve a socket
         beq.s    open_chan_block_init
; Reserve a socket and set it up on W5300
         bsr      reserve_socket
         tst.b    d0
         blt.s    open_chan_sock_alloc_fail     ; d0 < 0 == allocation failed, else sock #
open_channel_open_socket
         move.b   d0,d1
         bsr      new_source_port               ; d0 <= source port
		 cmp.l 		#'TCP_',d6
		 beq.s 	  open_socket_use_tcp
         move.b   #SOCK_MODE_UDP,d2
		 bra.s 	  open_socket_open_w5300
open_socket_use_tcp
         move.b   #SOCK_MODE_TCP,d2
open_socket_open_w5300
         bsr      w5300_socket
; Initialize driver-specific storage in channel def block
open_chan_block_init
         move.l   #0,CHAN_CONT_ADDR(a0)   ; Clear continuation address
		 move.b   #0,IO_SEND_STARTED(a0)
		 move.l 	#0,IO_BYTES_SENT(a0)
         moveq    #0,d0
         rts
notme
         moveq    #-7,d0            ; "not found" == driver name does not match
         rts
open_chan_sock_alloc_fail
; TODO Check if we should deallocate all allocated memory at this stage?
         moveq    #ERR.IU,d0        ; "In use" == can't allocate socket because all of them are in use   
         rts
;
open_channel_fail
         moveq    #ERR.OM,d0
         movea.l  (a7)+,a0
         rts
close_channel
         bsr.s    release_and_close_sockets
         movea.w  mem.rchp,a4
         jsr      (a4)
         rts
; a0 = chan def block
; a3 = drv def block
release_and_close_sockets
         bsr      find_socket_reservation
         cmpi.b   #-1,d0
         beq.s    release_and_close_end
         bsr      socket_close
         bsr      release_socket
         bra      release_and_close_sockets
release_and_close_end
         rts
;
channel_IO
         lea      CHAN_LOCAL_VARS(a0),a5
         cmpi.b   #0,d3                      ; D3==0 if first call, D3==-1 if re-entering a not-complete call
         beq.s    channel_IO_check_timedout
         cmpi.l   #0,CHAN_CONT_ADDR(a0)      ; Check if the chan def block contains a continuation address
         beq.s    channel_IO_check_operation ; If it was 0 then we don't have a continuation address
         movea.l  CHAN_REG_STORE(a0),a2      ; Restore A2 (TODO: set of registers)
         move.l   CHAN_REG_STORE+4(a0),d1    ; Return address to push on to the stack
         move.l   d1,-(a7)
         movea.l  CHAN_CONT_ADDR(a0),a1
         move.l   #0,CHAN_CONT_ADDR(a0)      ; Reset continuation so that we don't call it again
         jmp      (a1)
channel_IO_check_timedout
; We arrive here with a new operation (D3=0)
; Check if a previous operation timed out and left a continuation
; If so, cleanup resources associated with the previous call
         cmpi.l   #0,CHAN_CONT_ADDR(a0)
         beq.s    channel_IO_check_operation ; No continuation, nothing to clean up
; Clean up previous call's resources
; Check if there are sockets reserved for this channel (a0 points to chan def block)
         bsr      release_and_close_sockets
channel_IO_check_operation
; TODO Consider changing this into a vectored dispatch table
		cmpi.b 		#IP_CONNECT,d0
		beq.s 		ip_connect_impl
		cmpi.b 		#io.sstrg,d0
		beq.s 		ip_send_impl
		cmpi.b 		#QE_IO_DRV_INFO,d0
		beq.s 		driver_info
		cmpi.b 		#IP_GETHOSTBYNAME,d0
		beq 		ip_gethostbyname_impl
		cmpi.b 		#IP_INET_ATON,d0
		beq 		ip_inet_aton_impl
		cmpi.b 		#IP_INET_NTOA,d0
		beq 		ip_inet_ntoa_impl
		cmpi.b 		#IP_SENDTO,d0
		beq 		ip_sendto_impl
		cmpi.b 		#IP_RECVFM,d0
		beq 		ip_recvfrom_impl
; When doing "INPUT #3,a$" both QDOS and Minerva first call the driver with TRAP #3,d0=0x0b (sd.chenq) to
; get screen dimensions. Obviously , when there is no screen, we need to return an error code to signal
; that io.fline should be used instead
		cmpi.b 		#$0b,d0
		bne.s 		io_exit
; error code -15 (bad parameter) is used to signal to the calling code that the driver does not
; support editing and that the caller should fall back to calling io.fline (TRAP #3, d0=2) instead
		moveq 		#-15,d0
		rts
io_exit
         moveq    #0,d0
         rts
driver_info
         movea.l  a3,a1
         moveq    #0,d0
         rts
;
;IP_CONNECT
;
;Provides connect(2) functionality
;
;  TCP: opens connection to host:port
;  UDP: (re)sets peer address to host:port
;
;	Input
;
;	D0 = IP_CONNECT
;	D1 = (int) namelen
;	D3 = (short) timeout (-1)
;    
;	A0 = (chanid_t) Channel ID
;	A2 = (struct  sockaddr  *) name;
;
;	Output
;
;	D0 = result
;
;  TCP: opens connection
;  UDP: (re)sets peer address
;
;  regardless of the timeout specified, the socket will remain 
;  blocked (any IO will timeout or be delayed) until the connection 
;  buildup succeeded or failed.
ip_connect_impl
        lea    		CHAN_LOCAL_VARS(a0),a5
        move.l 		a0,IO_CHANDB(a5)
        move.l 		a1,IO_BUFFER(a5)
        move.l 		a3,IO_DRVDB(a5)
        move.l 		a6,IO_SYSVARS(a5)
; TODO Check that address family == AF_INET
        bsr    		find_socket_reservation
        tst.b  		d0
        blt.s  		ip_connect_no_socket
        move.l 		d0,d1                   ; Socket number
        move.l 		STRUCT_SA_DIP(a2),d2    ; Destination ip
        move.w 		STRUCT_SA_DPORT(a2),d3  ; Destination port
		bsr 		w5300_connect
        moveq 		#0,d0
        rts
ip_connect_no_socket
        moveq    #-1,d0
        rts

;		IP_SEND
;
;Provides send(2) functionality
;
;	Input
;
;	D0 = IP_SEND;
;	D1 = (uint) flag;
;	D2 = (int) buffer size;
;	D3 = (short) timeout (should be -1)
;
;	A0 = (chanid_t) channel ID
;	A1 = (void *) buffer address
;
;	Output
;
;	D0 = result
;	D1 = (int) bytes written
;
;	A1 = buffer address + bytes written
;
ip_send_impl
		tst.l 		d2
		bne.s		ip_send_impl_start
		moveq 		#0,d1
		moveq		#err.nc,d0
		rts
ip_send_impl_start
        lea 		CHAN_LOCAL_VARS(a0),a5
		tst.w 		d3
		bne.s 		ip_send_continuation_call
		move.b 		#0,IO_SEND_STARTED(a5)		; Send operation has not started yet (w5300 layer will mark it as started)
		move.l 		#0,IO_BYTES_SENT(a5)		; If this is a beginning of a new send operation then 0 bytes sent so far
		move.l 		d2,IO_BYTES_TO_SEND(a5) 	; Save total number of bytes to send
ip_send_continuation_call
        move.l 		a0,IO_CHANDB(a5)
        move.l 		a1,IO_BUFFER(a5)
        move.l 		a3,IO_DRVDB(a5)
        move.l 		a6,IO_SYSVARS(a5)
        bsr    		find_socket_reservation
        tst.b  		d0
        blt.s  		ip_sendto_no_socket
; Figure out number of bytes to send on this call
; If send operation in progress then don't try to send any bytes
; Otherwise find out bytes remaining by subtracting BYTES_SENT from BYTES_TO_SEND
; If bytes remaining is less than available space in socket buffer then use bytes remaining
; Otherwise send bytes equal to space available in socket buffer
		clr.l 		d2
		move.b 		IO_SEND_STARTED(a5),d7
		bne.s 		send_impl_call_w5300
		move.l 		IO_BYTES_TO_SEND(a5),d2
		sub.l 		IO_BYTES_SENT(a5),d2
        bsr 		w5300_send_bytes_available 	; Returns bytes available in socket send buffer in d1, preserves socket # in d0
		cmp.l 		d2,d1
		bcs.s 		ip_send_partial 	; If output size is smaller than bytes available in socket send buffer
		bra.s 		send_impl_call_w5300
ip_send_partial
		move.l 		d1,d2 				; Send max bytes that fit in socket buffer
send_impl_call_w5300
		move.b 		d0,d1 					; Socket # to d1
		movea.l 	IO_BUFFER(a5),a1
; TODO Add offset for bytes already sent???
		movea.l 	IO_CHANDB(a5),a0
		bsr 		w5300_send_impl
; Check return status and bytes sent and adjust call return status and channel variables
; Always update number of bytes written so far
; If the return status was err.nc then return that
; If the return status was 0==ok then check if we have sent all bytes and return 0 or err.nc accordingly
		add.l 		d1,IO_BYTES_SENT(a5)
		cmpi.b 		#err.nc,d0
		beq.s 		send_impl_return
		move.l 		IO_BYTES_TO_SEND(a5),d7
		cmp.l 		IO_BYTES_SENT(a5),d7
		bhi.s 		send_impl_return_nc
		moveq		#0,d0
		rts
send_impl_return_nc
		moveq 		#err.nc,d0
send_impl_return
		rts
;
; IP_SENDTO
;
; Provides sendto(2) functionality
;
;   Input
;
;   D0 = IP_SENDTO;
;   D1 = (uint) flag;
;   D2 = (int) number of bytes to write;
;   D3 = (short) timeout (should be -1)
;
;   A0 = (chanid_t) channel ID
;   A1 = (void *) buffer address
;   A2 = parameter block (2 long words)
;      params0 = (struct sockaddr*) to
;      params1 = (int) tolen;
;
;
;   Output
;
;   D0 = result
;      +ve => number of bytes sent
;      -ve => error code
;
ip_sendto_impl
; TODO Check if buffer size > 0 && valid destination && port != 0
; TODO Check that buffer size <= memory size for socket
         lea      CHAN_LOCAL_VARS(a0),a5
         move.l   a0,IO_CHANDB(a5)
         move.l   a1,IO_BUFFER(a5)
         move.l   a3,IO_DRVDB(a5)
         move.l   a6,IO_SYSVARS(a5)
         movea.l  (a2),a4                 ; a4 == pointer to struct sockaddr
         move.l   4(a2),d4                ; Length of struct sockaddr
; TODO Check that address family == AF_INET
         bsr      find_socket_reservation
         tst.b    d0
         blt.s    ip_sendto_no_socket
         move.l   d0,d1                   ; Socket number
         move.l   d2,d0                   ; Number of bytes to write
         move.l   STRUCT_SA_DIP(a4),d2    ; Destination ip
         move.w   STRUCT_SA_DPORT(a4),d3  ; Destination port
         move.l   IO_BUFFER(a5),a1
         bsr      w5300_sendto_impl
         rts                              ; Return number of bytes written in d0
ip_sendto_no_socket
; TODO proper error code
         moveq    #-1,d0
         rts
;
; IP_RECVFM
;
; Provides recvfrom(2) functionality
;
;    D0 = IP_RECVFM
;    D1 = (uint) flag
;    D2 = (int) buffer size
;    D3 = (short) timeout (-1)
;
;    A0 = (chanid_t) channel ID
;    A1 = (void *) buffer address
;    A2 = parameter block (2 long words)
;       params0 = (struct sockaddr*) from
;       params1 = (int) fromlen;
;
;    Output
;
;    D0 = result
;       +ve => number of bytes sent
;       -ve => error code
;    D1 = size of returned struct sockaddr
;
ip_recvfrom_impl
; TODO flags ignored
         tst.w    d2
         bne.s    recvfrom_buffer_size_ok
         moveq    #ERR.OR,d0                 ; Out of range
         rts
recvfrom_buffer_size_ok
; Store parameters
         lea      CHAN_LOCAL_VARS(a0),a5
         move.l   a1,IO_BUFFER(a5)
         move.l   a2,IO_PARAM_BLOCK_PTR(a5)
         move.l   d1,IO_FLAGS(a5)
         move.l   d2,IO_BUFSIZ(a5)
         bsr      find_socket_reservation    ; Get socket # in d0.l
         tst.b    d0
         bmi.s    recvfrom_no_socket_allocated
         move.w   d0,IO_SOCK_NUM(a5)
         bsr      w5300_recv_bytes_available      ; Overwrites d1 and a2, d1 = # bytes available
         tst.w    d1
         bne.s    recvfrom_bytes_available
         moveq    #ERR.NC,d0                 ; Not complete, try again later
         rts
recvfrom_bytes_available
         move.w   IO_SOCK_NUM(a5),d1
         move.l   IO_BUFSIZ(a5),d0
         move.l   IO_BUFFER(a5),a1
         bsr      w5300_recvfrom_impl
; TODO return value processing
         rts
recvfrom_no_socket_allocated
         moveq    #ERR.NO,d0                 ; Not open
         rts
;
; Provides gethostbyname(2) functionality
;
;    Input
;
;    D0 = IP_GETHOSTBYNAME
;    D3 = (short) timeout (-1)
;
;    A0 = (chanid_t *) channel ID
;         A1 = (char *) name       // NULL terminated
;         A2 = (struct hostent *)hostent buffer   // minimum of 500 bytes
;
; The buffer pointed to by A2 must be at large enough to hold the
; largest struct hostent returned.
;
;    D0 = result
;
ip_gethostbyname_impl
         move.l   a0,IO_CHANDB(a5)
         move.l   a3,IO_DRVDB(a5)
         move.l   a6,IO_SYSVARS(a5)
         move.l   a1,IO_HOSTNAME_PTR(a5)
         move.l   a2,IO_STRUCT_HE_PTR(a5)
         lea      STRUCT_HE_HADDRLIST(a2),a2
         bsr      ip_inet_aton_impl                ; Returns ip address in d7 if successful
         tst.b    d0
         bne.s    lookup_hostname
         movea.l  IO_HOSTNAME_PTR(a5),a1
         movea.l  IO_STRUCT_HE_PTR(a5),a2
         bsr      hostent_init
         move.l   d7,d0
         bsr      hostent_set_single_ip
         movea.l  IO_CHANDB(a5),a0
         moveq    #0,d0
         rts
; TODO implement socket layer. Now uses a static fake response.
lookup_hostname
; Reserve a socket
         movea.l  IO_CHANDB(a5),a0
         movea.l  IO_DRVDB(a5),a3
         bsr      reserve_socket
; TODO check error
         move.w   d0,IO_SOCK_NUM(a5)
; Create and fill in a DNS query packet. For now, release it after creating it
         movea.l  IO_HOSTNAME_PTR(a5),a0
         movea.l  a0,a4
         bsr      strlen
         movea.l  IO_DRVDB(a5),a3
         lea      QE_MEM_UH_PTR(a3),a0
         bsr      create_dns_query_buffer
         move.l   a2,IO_DNS_QUERY_BUF_PTR(a5)
         tst.b    d0
         bne.s    create_dummy_response
; Open a UDP socket for the query
         move.w   IO_SOCK_NUM(a5),d0
         movea.l  IO_CHANDB(a5),a0
         bsr      socket_open_udp
         tst.b    d0
         beq.s    release_query_block
         cmpi.b   #err.nc,d0
         bne.s    release_query_block
         move.l   a1,CHAN_CONT_ADDR(a0)
         bra.s    lookup_hostname_exit
; TODO call w5300_sendto_impl
; Release the DNS query heap block
release_query_block
         movea.l  IO_DNS_QUERY_BUF_PTR(a5),a0
         suba.l   #8,a0                      ; Point to beginning of allocated user heap block
         movea.l  IO_DRVDB(a5),a3
         lea      QE_MEM_UH_PTR(a3),a1
         bsr      deallocate_user_heap
create_dummy_response
         movea.l  IO_HOSTNAME_PTR(a5),a1
         movea.l  IO_STRUCT_HE_PTR(a5),a2
         bsr.s    hostent_init
         lea      DNS_DUMMY_RESPONSE,a3
         movea.l  a2,a0                      ; a0 now points to struct hostent
         move.l   a5,-(a7)                   ; Save frame pointer
         bsr      get_ip_from_dns_response   ; WIP: Try to fill in hostent from dns response
         movea.l  (a7)+,a5
; Close and release the reserved socket
         movea.l  IO_CHANDB(a5),a0
         movea.l  IO_DRVDB(a5),a3
         move.w   IO_SOCK_NUM(a5),d0
; Close the socket
; TODO: how to close and release when operation does not complete within the allocated timeout??!!
         bsr      socket_close
         bsr      release_socket
; TODO check error
         moveq    #0,d0
; Exit with whatever code is in d0
lookup_hostname_exit
         movea.l  IO_CHANDB(a5),a0
         rts
;
; Initialize a struct hostent with a host name passed in
; Parameters:
;     A1: pointer to null-terminated host name string
;     A2: pointer to struct hostent
hostent_init
         lea      STRUCT_HE_SIZE(a2),a3
         move.l   a3,STRUCT_HE_HNAME(a2)
         move.l   a2,-(a7)
         movea.l  a3,a2
         move.w   #DNS_MAX_NAME_LEN,d0
         bsr.s    strncpy
         move.l   a2,d1                         ; On return, A2 points at one byte past the string terminating null byte
         move.l   (a7)+,a2                      ; Restore pointer to struct hostent
         btst     #0,d1
         beq.s    hostent_init_set_haddrlist
         addq.l   #1,d1
hostent_init_set_haddrlist
         move.l   d1,STRUCT_HE_HADDRLIST(a2)
         movea.l  d1,a3
         move.l   #0,(a3)
         move.l   #AF_INET,STRUCT_HE_HADDRTYPE(a2)       ; Only IPv4 supported so this is fixed
         move.l   #AF_INET_ADDR_LEN,STRUCT_HE_HLEN(a2)   ; Number of bytes per address (==4)
         rts
; DEPRECATED, TODO: remove Add an ip address to a struct hostent
; PREREQUISITE: struct hostent has been initialized so that the ip address list pointer is valid
; Parameters:
;     A2: pointer to a struct hostent buffer with sufficient space
;     D0.l ip address to add
;
hostent_set_single_ip
         movea.l  STRUCT_HE_HADDRLIST(a2),a3
; 0-7 = table of address pointers (1 entry + terminator), 8-11 = null terminator for alias table
         lea      12(a3),a4
         move.l   a4,(a3)+
         move.l   d0,(a4)
         clr.l    (a3)+
         move.l   a3,STRUCT_HE_HALIASES(a2)
         clr.l    (a3)
         rts
; Copy at most n bytes from one string to another
; Always terminates the target with a null byte so can use n+1 bytes of target buffer
; Parameters:
;     A1: pointer to null-terminated string to copy from
;     A2: pointer to pre-allocated buffer to copy to
;     D0.w: maximum number of bytes to copy (excluding terminating null byte)
; Returns:
;     D0.w  number of bytes copied (excluding terminating null)
strncpy
         cmp.w    #0,d0
         bhi.s    strncpy_maxlen_ok
         move.b   #0,(a2)+
         rts
strncpy_maxlen_ok
         move.w   #0,d2
         subq.w   #1,d0       ; Subtract one to make correct # of loops using dbra
strncpy_copy_loop
         addq.w   #1,d2
         move.b   (a1)+,d1
         move.b   d1,(a2)+
         beq.s    strncpy_string_end
         dbra     d0,strncpy_copy_loop
         move.b   #0,(a2)+
strncpy_string_end
         move.w   d2,d0
         rts
; Strlen - return number of characters in a c-style null-terminated string
; A0: pointer to start of string
; Returns:
; D0.w: length of string
strlen
         moveq    #0,d0
strlen_loop
         move.b   (a0)+,d1
         beq.s    strlen_exit
         addq.w   #1,d0
         bra      strlen_loop
strlen_exit
         rts
;
; IP_INET_ATON
;
; Provides inet_aton(2) functionality
;
;    Input
;
;         D0 = IP_INET_ATON;
;         D3 = (short) timeout (-1)
;    A0 = (chanid_t) channel ID
;         A1 = (char *) name
;         A2 = ( struct in_addr *)inaddr buffer
;
;    Output
;
;    D0 = result
;
ip_inet_aton_impl
         move.l   a0,-(a7)             ; Save channel id
         movea.l  a1,a0
         bsr      strlen               ; Get string length in d0, a0 = pointer to string
         moveq    #0,d4
         move.w   d0,d4
         bsr      read_ip_address
         movea.l  (a7)+,a0
         move.l   d7,(a2)
         rts
;
;IP_INET_NTOA
;
;Provides inet_ntoa(2) functionality
;
;   Input
;
;   D0 = IP_INET_NTOA
;   D3 = (short) timeout (-1)
;   A0 = (chanid_t) channel ID
;   A1 = (struct in_addr *) net address buffer
;   A2 = (char *) result buffer
;
;   Output
;
;   D0 = result
ip_inet_ntoa_impl
         move.l   a0,-(a7)             ; Need to preserve channel id
         move.l   (a1),d0
         movea.l  a2,a0
         bsr.s    long_to_ip_string
         movea.l  (a7)+,a0
         moveq    #0,d0
         rts
long_to_ip_string
         rol.l   #8,d0
         bsr.s   byte_to_string
         move.b  #'.',(a0)+
         rol.l   #8,d0
         bsr.s   byte_to_string
         move.b  #'.',(a0)+
         rol.l   #8,d0
         bsr.s   byte_to_string
         move.b  #'.',(a0)+
         rol.l   #8,d0
         bsr.s   byte_to_string
         move.b  #0,(a0)+
         rts
byte_to_string
         moveq   #0,d1
         moveq   #0,d2           ; Clear flag register
         move.b  d0,d1
         divu    #100,d1
         tst.w   d1
         beq.s   byte_to_string_handle_tens
         add.b   #$30,d1
         move.b  d1,(a0)+
         moveq   #1,d2           ; Flag to tell we have hundreds
byte_to_string_handle_tens
         clr.w   d1
         swap    d1              ; Remainder to lower word
         divu    #10,d1
         tst.b   d2
         bne.s   byte_to_string_have_hundreds   ; There are non-zero hundreds so we can print a potential zero
         tst.w   d1
         beq.s   byte_to_string_handle_ones
byte_to_string_have_hundreds
         add.b   #$30,d1
         move.b  d1,(a0)+
byte_to_string_handle_ones
         swap    d1
         add.b   #$30,d1
         move.b  d1,(a0)+
         rts
; SuperBASIC procedure that connects a socket. Takes a channel, host and port as parameters
TCP_CONN
; Check that the procedure was called with three parameters
        lea      24(a3),a0	; 8 bytes per parameter
        cmpa.l   a0,a5
        bne.s    tcpconn_bad_param
; Load up first parameter definition word to d0 (a3 pointing to first parameter is relative to a6)
		lea 		0(a3),a0
		adda.l 	 	a6,a0
		move.w 		(a0),d0
; Check that the first paramater is preceded by a '#' character
		andi.w 		#$0080,d0
		beq.s 		tcpconn_bad_param
        bra.s    tcpconn_chan_param_hash_set
tcpconn_bad_param
         moveq    #err.bp,d0
         rts
tcpconn_chan_param_hash_set
		move.l 		a5,d5 				; Save A5 that points to last parameter
		lea 		8(a3),a5
        movea.w  sb.gtint,a4
        move.l   BV_RIP(a6),a1
        jsr      (a4)
        beq.s    tcpconn_chan_param_ok
        rts
tcpconn_chan_param_ok
; Channel number parameter is now on maths stack and A1 updated to point to it, save offset on stack
		move.l	 	a1,-(a7)
; Prepare to read next parameter which is the host name string, move start and end pointers by one param position
		lea 		8(a5),a5
		lea 		8(a3),a3
        movea.w  	sb.gtstr,a4
        move.l   	BV_RIP(a6),a1
        jsr      	(a4)
        beq.s    	tcpconn_hostname_param_ok
		clr.l 		(a7)+ 				; ditch saved param offset
        rts
;		cmp.w 		#1,d3 				; Check only one integer was fetched
;		beq.s 		tcpconn_numints_ok
tcpconn_hostname_param_ok
		move.l	 	a1,-(a7)
		lea 		8(a5),a5
		lea 		8(a3),a3
        movea.w  	sb.gtint,a4
        move.l   	BV_RIP(a6),a1
        jsr      	(a4)
        beq.s    	tcpconn_port_param_ok
		adda.l 		#8,a7 				; ditch saved param offsets
        rts
tcpconn_port_param_ok
		move.l	 	a1,-(a7)
; All parameters are on the maths stack. Now check if the channel specified in param #1 is an open socket channel
		; Get channel number from maths stack (it's now the third item on the stack)
        move.l   	8(a7),a1 			; Param offset for channel #
		adda.l 		a6,a1
		move.w 		(a1),d0
		; Find channel id based on channel number, chan # in d0
		move.l 		bv_chbas(a6),a0
		mulu 		#$28,d0
		adda.l 		d0,a0
		cmp.l 		bv_chp(a6),a0
		bge.s 		chan_not_found
		move.l 		0(a6,a0.l),d0
		; d0 now contains channel id, if it's negative then channel is not open, otherwise store it on the stack
		bmi.s 		chan_not_found
		move.l 		d0,-(a7)

		link 		a5,#-8				; addr family 2 bytes, port 2 bytes, address 4 bytes
		move.w 		#AF_INET,-8(a5)
		move.l 		16(a7),a1 			; Get port number from math stack using offset stored in stack
		adda.l 		a6,a1
		move.w 		(a1),d0
		move.w 		d0,-6(a5)

		; Do an nslookup on the name that was passed in
		; Get a pointer to the hostname string on maths stack
		move.l 		20(a7),a1
		adda.l 		a6,a1
		move.l 		a5,-(a7)
; Call C implementation
; !!!! Overwrites math stack with garbage for some reason !!!!
		move.l 		a1,-(a7)
		lea 		_nslookup_impl,a4
		jsr 		(a4)
		clr.l 		(a7)+ 				; Remove the parameter that was passed to function from stack
		movea.l		(a7)+,a5
; Verify the return value from nslookup_impl - check that an IP address was found for the hostname
		tst.l 		d0
		beq.s 		tcpconn_ip_not_found
; TODO >>>>> set up a struct sockaddr and trap #3 to call "connect" on the channel
		move.l 		d0,-4(a5) 			; IP address
		move.l 		#IP_CONNECT,d0 		; Operation code
		move.w 		#6,d1 				; Namelen (not used)
		move.l 		#0,d3 				; Timeout
		move.l 		12(a7),a0 			; Channel id
		lea 		-8(a5),a2			; struct sockaddr *
		move.l 		a5,-(a7)
		trap 		#3
		move.l 		(a7)+,a5
		unlk 		a5
		clr.l 		(a7)+ 				; clear channel id from stack
		; Adjust math stack for a clean return
		move.l 		8(a7),d1 			; Offset for first short int
		addq.l 		#2,d1
		move.l  	d1,bv_rip(a6)
		adda.l 		#12,a7 				; ditch saved param offsets
        moveq    	#0,d0
        rts
chan_not_found
		adda.l 		#12,a7 				; ditch saved param offsets
        moveq    	#err.no,d0
        rts
tcpconn_ip_not_found
		unlk 		a5
		adda.l 		#16,a7 				; ditch channel id and parameter pointers
		moveq 		#err.nf,d0
		rts
; End TCP_CONN procedure
; SuperBASIC procedure that closes a socket. Takes socket number as parameter
TCP_CLS
; Check that the procedure was called with one parameter
         lea      8(a3),a0	; 8 bytes per parameter
         cmpa.l   a0,a5
         beq.s    tcpcls_num_params_ok
         moveq    #err.bp,d0
         rts
tcpcls_num_params_ok
         movea.w  sb.gtint,a4
         move.l   BV_RIP(a6),a1
         jsr      (a4)
         tst.l    d0
         beq.s    tcpcls_int_param_ok
         moveq    #err.bp,d0
         rts
tcpcls_int_param_ok
		cmp.w 		#1,d3 				; Check only one integer was fetched
		beq.s 		tcpcls_numints_ok
         moveq    #err.bp,d0
         rts
tcpcls_numints_ok
		move.w 		0(a6,a1.l),d1 		; Get parameter into D1
		addq.l 		#2,BV_RIP(a6) 		; and adjust stack accordingly
		movem.l 	d0-d3/a0-a5,-(a7)
; Call C implementation
;		 move.l   a1,-(a7)
;		 lea      _nslookup_impl,a4
;		 jsr 	  (a4)
;		 move.l   d0,d4 					; Store result
;		 clr.l 		(a7)+ 					; Remove the parameter that was passed to function from stack
		movem.l 	(a7)+,d0-d3/a0-a5
; Call succeeded, 
		 moveq 		#0,d0
         rts
; End TCP_CLS procedure
; SuperBASIC function that creates a socket and returns its number
TCP_SOCK
; Check that the function was called with no parameters
         cmpa.l   a3,a5
         beq.s    tcpsock_num_params_ok
         moveq    #err.bp,d0
         rts
tcpsock_num_params_ok
		movem.l 	d0-d3/a0-a5,-(a7)
; Call C implementation
;		 move.l   a1,-(a7)
;		 lea      _nslookup_impl,a4
;		 jsr 	  (a4)
;		 move.l   d0,d4 					; Store result
;		 clr.l 		(a7)+ 					; Remove the parameter that was passed to function from stack
		movem.l 	(a7)+,d0-d3/a0-a5
; Call succeeded, 
; Return number of socket that was reserved
         moveq.l  #2,d1 		 ; Returning a word so need two bytes on math stack
         move.l   BV_RIP(a6),a1
         move.w   qa.resri,a4    ; Vector to make sure required space is available on the maths stack, d1==required bytes
         jsr      (a4)           ; No error status is returned on QDOS!
         move.l   BV_RIP(a6),a1  ; Load maths stack head pointer
         suba.l   #2,a1
         move.l   a1,BV_RIP(a6)
		 
         move.w 	#1,0(a6,a1.l)
         moveq    	#3,d4                         ; Return a word integer
		 moveq 		#0,d0
         rts
; End TCP_SOCK function
KEYWORDS dc.w     3             ; No of procedures we are linking in
         dc.w     QE_UNLOAD-*   ; Pointer to code of first procedure
         dc.b     9,'QE_UNLOAD' ; Name of first procedure
         dc.w     TCP_CLS-*     ; Close a TCP socket
         dc.b     7,'TCP_CLS'
         dc.w     TCP_CONN-*    ; Connect to remote host
         dc.b     8,'TCP_CONN'
         dc.w     0             ; End marker for procedures
         dc.w     2             ; No of functions we are linking in
         dc.w     NSLOOKUP-*    ; Pointer to code of first function
         dc.b     8,'NSLOOKUP'  ; Name of first function
         dc.w     TCP_SOCK-*    ; Create a TCP socket and return its number
         dc.b     8,'TCP_SOCK'
         dc.w     0             ; End marker for functions
; TCP_SOCK
; TCP_CLS
; TCP_CONN
; TCP_AVAIL
; TCP_RDLN
; TCP_SDLN
 ; Wireshark capture of DNS query response to www.lekane.net
DNS_DUMMY_RESPONSE
         dc.l     $00068180,$00010005,$00000000,$03777777,$066c656b,$616e6503,$6e657400,$00010001
         dc.l     $c00c0005,$00010000,$012b0015,$1270726f,$642d6575,$77312d64,$69616c6f,$677565c0
         dc.l     $10c02c00,$05000100,$00003b00,$0e0b7061,$62303230,$2d657577,$31c010c0,$4d000500
         dc.l     $01000001,$2b003416,$70616230,$32302d65,$7577312d,$32303732,$38343839,$36310965
         dc.l     $752d7765,$73742d31,$03656c62,$09616d61,$7a6f6e61,$77730363,$6f6d00c0,$67000100
         dc.l     $01000000,$3b000436,$f6c85fc0,$67000100,$01000000,$3b000436
         dc.b     $ab,$e1,$bf
         end

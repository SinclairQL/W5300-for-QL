; On entry from driver:
; a1 points to driver name (with no length word at beginning, fixed length of 3 bytes)
; a2 points to string passed to driver in open call, e.g. "udp_127.0.0.1:80" preceded
; by a length word
match_udp_drv_name
         bsr      cmpic
         bne      udp_drv_no_match
         move.w   (a2),d4                             ; Length of string to d4
         movea.l  a2,a1
         adda.w   #6,a1                               ; a1 now points to anything after 'udp_'
         subq.w   #4,d4                               ; We consumed the first four bytes when we recognized 'udp_'
         bsr      read_ip_address                     ; updates d4
         beq      ip_address_known
         move.w   (a2),d4
         movea.l  a2,a1
         adda.w   #6,a1                               ; a1 now points to anything after 'udp_'
         subq.w   #4,d4                               ; We consumed the first four bytes when we recognized 'udp_'
         bsr      resolve_host_name
         bne      udp_drv_no_match
ip_address_known
         cmpi.w   #2,d4                               ; There should be at least two more characters for ':' + port number
         blt      udp_drv_no_match
         move.b   (a1)+,d1
         cmpi.b   #':',d1
         bne      udp_drv_no_match
         subq.w   #1,d4                               ; Account for the ':' that was read
         bsr      rdnum
         bne      udp_drv_no_match
         moveq    #0,d0
         rts
udp_drv_no_match
         moveq    #-1,d0
         rts
cmpic    moveq    #1,d0                               ; Default return code: error
         moveq    #2,d1                               ; driver name is three characters long
         move.w   (a2),d2
; Candidate name should be at least four characters long ('udp_') to have any chance of matching
         cmpi.w   #3,d2
         bls      cmpiexit
cmploop  move.b   0(a1,d1.w),d4
         cmp.b    2(a2,d1.w),d4
         beq      cmplend
         add.b    #$20,d4                             ; to lowercase: 'A' = $41, 'a'=$61
         cmp.b    2(a2,d1.w),d4
         bne      cmpiexit
cmplend  dbf      d1,cmploop
         cmpi.b   #'_',6(a2,d1.w)
         bne      cmpiexit
         moveq    #0,d0
cmpiexit rts
isnum    moveq    #1,d0
         cmpi.b   #$30,d1
         blt      notnum
         cmpi.b   #$39,d1
         bgt      notnum
numok    moveq    #0,d0
notnum   rts
;
;
; a1 = pointer to start of string
; d4.w = length of string
rdnum    moveq    #0,d2                               ; Accumulator for the number
         moveq    #0,d3                               ; loop counter
rdnloop  cmp.w    d4,d3
         bge      rdldone
         move.b   0(a1,d3.w),d1
         bsr      isnum
         tst.b    d0
         bne      rdldone
         sub.b    #$30,d1
         ext.w    d1
         mulu     #10,d2
         add.w    d1,d2
         addq.w   #1,d3
         bra      rdnloop
rdldone  tst.w    d3
         beq      no_number_read
         moveq    #0,d0
         rts
no_number_read
         moveq    #-1,d0
         rts
;
rdbyte   bsr      rdnum
         tst.b    d0
         bne      rdb_exit_err
         cmpi.w   #255,d2
         bgt      rdb_exit_err
         cmpi.w   #0,d2
         blt      rdb_exit_err
         moveq    #0,d0
         rts
rdb_exit_err
         moveq    #-1,d0
         rts
; Read an ip v4 address
; a1 = pointer to start of string
; d4.w = length of string
; 
; Returns
; d0 = success status, 0=ok
; d7 = ip address as long word
read_ip_address
         moveq    #2,d6                               ; Read the first three octets
read_ip_loop
         bsr      read_byte_and_update_regs
         tst.b    d0
         bne      not_ip
         cmpi.b   #'.',(a1)+
         bne      not_ip
         subq.w   #1,d4                               ; Update remaining length
         dbf      d6,read_ip_loop
         bsr      read_byte_and_update_regs
         tst.b    d0
         bne      not_ip
         rts
not_ip   moveq    #-1,d0
         rts
read_byte_and_update_regs
         bsr      rdbyte
         tst.b    d0
         bne      abort_read
         asl.l    #8,d7
         move.b   d2,d7                               ; d2 is the accumulated byte value from 'rdbyte'
         adda.w   d3,a1                               ; d3 from 'rdbyte' shows how many chars were read
         sub.w    d3,d4
abort_read
         rts
; Read and resolve host name
; a1=pointer to start of string, read until ':'
; d4.w = length of string
resolve_host_name
         movea.l  a1,a3
find_host_name
         move.b   (a3)+,d1
         cmpi.b   #':',d1
         beq      colon_after_host_name_found
         dbf      d4,find_host_name
         bra      invalid_host_name                   ; No colon after host name found -> invalid
colon_after_host_name_found
         suba.l   a1,a3
         move.w   a3,d2
         subq.w   #1,d2                               ; Length of string before ':', a3 is always incremented at least once
         cmp.w    #0,d2                               ; Was colon the first character? i.e. no host name given
         beq      invalid_host_name
; a1 still points to start of string, d2.w contains length of hostname string
;
; TODO call resolver here with the hostname
         moveq    #0,d0
         rts
invalid_host_name
         moveq    #1,d0
         rts

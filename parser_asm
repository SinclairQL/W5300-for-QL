cmpic    moveq    #1,d0
         moveq    #2,d1
         move.w   (a2),d2
; Candidate name should be at least four characters long ('udp_') to have any chance of matching
         cmpi.w   #3,d2
         bls      cmpiexit
cmploop  move.b   0(a1,d1.w),d4
         cmp.b    2(a2,d1.w),d4
         beq      cmplend
         add.b    #$20,d4
         cmp.b    2(a2,d1.w),d4
         bne      cmpiexit
cmplend  dbf      d1,cmploop
         cmpi.b   #'_',6(a2,d1.w)
         bne      cmpiexit
         moveq    #0,d0
cmpiexit rts
isnum    moveq    #1,d0
         cmpi.b   #$30,d1
         blt      notnum
         cmpi.b   #$39,d1
         bgt      notnum
numok    moveq    #0,d0
notnum   rts
; a1 = pointer to start of string
; d4.w = length of string
rdbyte   moveq    #0,d2                               ; Accumulator for the number
         moveq    #0,d3                               ; loop counter
         moveq    #0,d5                               ; Number of leading zeros
; handle leading zeros
rdbskip  cmp.w    d4,d3
         bge      check_loop_len
         move.b   0(a1,d3.w),d1
         cmpi.b   #'0',d1
         bne      rdb_leadzero_end
         addq.w   #1,d5
         addq.w   #1,d3
         bra      rdbskip
rdb_leadzero_end
         addq.w   #2,d5
rdbloop  cmp.w    d4,d3
         bge      check_loop_len
         cmp.w    d5,d3                               ; Number of leading zeros + 2, i.e. a maximum of three significant digits
         bgt      check_final_char
         move.b   0(a1,d3.w),d1
         bsr      isnum
         tst.b    d0
         bne      check_loop_len
         sub.b    #$30,d1
         ext.w    d1
         mulu     #10,d2
         add.w    d1,d2
         addq.w   #1,d3
         bra      rdbloop
check_loop_len
         tst.w    d3
         beq      not_byte
         cmpi.w   #255,d2
         bgt      not_byte
         bra      is_byte
check_final_char
         move.b   0(a1,d3.w),d1
         bsr      isnum
         tst.b    d0
         bne      is_byte
not_byte moveq    #-1,d0
         rts
is_byte  moveq    #0,d0
         rts
; Read an ip v4 address
; a1 = pointer to start of string
; d4.w = length of string
read_ip_address
         moveq    #2,d6                               ; Read the first three octets
read_ip_loop
         bsr      read_byte_and_update_regs
         tst.b    d0
         bne      not_ip
         cmpi.b   #'.',(a1)+
         bne      not_ip
         subq.w   #1,d4                               ; Update remaining length
         dbf      d6,read_ip_loop
         bsr      read_byte_and_update_regs
         tst.b    d0
         bne      not_ip
         rts
not_ip   moveq    #-1,d0
         rts
read_byte_and_update_regs
         bsr      rdbyte
         tst.b    d0
         bne      abort_read
         asl.l    #8,d7
         move.b   d2,d7                               ; d2 is the accumulated byte value from 'rdbyte'
         adda.w   d3,a1                               ; d3 from 'rdbyte' shows how many chars were read
         sub.w    d3,d4
abort_read
         rts

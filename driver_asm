; Set up the serio pointers area
         lea      ptrs,a0
         lea      io_ready,a2
         move.l   a2,(a0)+
         lea      fetch,a2
         move.l   a2,(a0)+
         lea      send,a2
         move.l   a2,(a0)
; Set up the driver linkage (standard version) block
         lea      lnkblk+$1C,a0
         lea      IO,a2
         move.l   a2,(a0)+
         lea      open,a2
         move.l   a2,(a0)+
         lea      close,a2
         move.l   a2,(a0)
         lea      lnkblk+$18,a0
         moveq    #mt_liod,d0        ; link in this driver
         trap     #1
         bne      bad_exit
;         bsr      init_w5
         bra      io_ready
; Remove driver from chain
         lea      lnkblk+$18,a0
         moveq    #mt_riod,d0        ; remove this driver
         trap     #1
         bra      io_ready
lnkblk   ds.l     $40
udpname  dc.w     'UDP'
; Insert W5300 code
;         in       mdv3_w5300_asm
; Insert driver name parser
         in       mdv3_parser_asm
pop_notme
         adda.w   #6,a7             ; Ditch saved string length (word) and pointer to start of string (long word)   
notme
         moveq    #-7,d0            ; "not found" == driver name does not match
         rts
open     movea.l  a0,a2
         move.w   (a2)+,d1
         cmpi.w   #4,d1
         bcs      notme   
         move.l   (a2)+,d2
         and.l    #$dfdfdfff,d2     ; Uppercase the first three characters
         cmpi.l   #'UDP_',d2
         bne      notme
         subq.w   #4,d1             ; Four characters have been read from driver name, update length remaining
         move.w   d1,-(a7)          
         move.l   a2,-(a7)
         move.w   d1,d4                             ; Length of string to d4
         movea.l  a2,a1                             ; Pointer to first character after udp_
         bsr      read_ip_address                     ; updates d4
         beq      ip_address_known
         move.w   4(a7),d4
         movea.l  (a7),a1
         bsr      resolve_host_name
         bne      pop_notme
ip_address_known
         cmpi.w   #2,d4                               ; There should be at least two more characters for ':' + port number
         blt      pop_notme
         move.b   (a1)+,d1
         cmpi.b   #':',d1
         bne      pop_notme
         subq.w   #1,d4                               ; Account for the ':' that was read
         bsr      rdnum
         bne      pop_notme
         adda.w   #6,a7             ; Ditch saved string length (.w) and pointer to start of string (.l)
         move.l   #$40,d1           ; reserve space for the channel definition block
         movea.w  mm_alchp,a4
         move.l   a0,-(a7)          ; Save the A0 from entry to open just in case the allocation fails
         jsr      (a4)
         bne      ra0ext
         addq.l   #4,a7             ; Ditch the saved A0, we won't need it any more
         move.l   #$20000,$22(a0)    ; Set up the screen buffer as the memory area this driver writes/reads
; Save ip address and port in driver linkage block
         move.l   d7,$18(a0)        ; ip address
         move.w   d2,$1c(a0)
         bra      io_ready
ra0ext   move.l   (a7)+,a0          ; Restore A0 and exit
         rts
close    movea.w  mm_rechp,a4
         jmp      (a4)
IO       movea.w  io_serio,a4        ; Deal with trap #3 . .
         jsr      (a4)               ; . . calls by IO.SERIO
*
* These three pointers are to:
*
*         io ready - here does nothing
*         fetch a byte to D1
*         send a byte from D1
*
* NOTE D1 has to end up containing the current position of the file
*      which is at $22(A0)
*
ptrs     ds.l     3
         rts
*
fetch
         movea.l   $22(a0),a1
         move.b    (a1),d1            ; Set the next byte to D1.B
fetch_1  addq.l    #1,$22(a0)         ; Increment the current address
io_ready moveq     #0,d0
bad_exit rts
*
send
         movea.l   $22(a0),a1
         move.b    d1,(a1)
         bra       fetch_1
